[{"content":" This blog is about Go by examples.\n ","href":"/","title":"Home"},{"content":"","href":"/docs/","title":"My Posts"},{"content":"","href":"/project/","title":"My Projects"},{"content":"Hello, I\u0026rsquo;m Tracey. I am a self-taught software engineer with applied mathematics background. After going through A Tour of Go, I found that Go was actually a neat and simple language to learn and started to develop more interest in programming. While still in my learning journey, I create this blog to share interesting problems and projects that I have done in Go, as well as some other useful resources.\nHope you like the blog and happy Go-ing!\n","href":"/about/","title":"About"},{"content":"Courses  A Tour of Go  Books  Cracking the Coding Interview by Gayle Laakmann McDowell  Articles  sync.RWMutex\nA nice write up of how to use sync.RWMutex to handle concurrent read/write access to shared resources.  ","href":"/resources/","title":"Resources"},{"content":"","href":"/authors/","title":"Authors"},{"content":"","href":"/tags/avl-tree/","title":"AVL Tree"},{"content":"Source code\nIntroduction AVL tree is a height-balanced binary search tree (BST). In an AVL tree, every node maintains a balance factor, which is defind as follows\nbalance_factor := height(left_subtree) - height(right_subtree)\rAccording to definition of a balanced tree, the balance factor of every node in the AVL tree is either -1, 0, or 1. When an insertion or deletion operation is performed, the tree\u0026rsquo;s height may change, so do the balance factors at nodes. Whenever the balance factor of a node goes over the range, the tree will re-balance itself by operating rotation at that node. One can find more details here.\nRotation Basically, there is 4 cases that the tree is imbalanced at a node, and correspondingly 4 rotation methods that will be performed to make the tree balanced. It is noted that the below images of illustration rotation operations and insertion example are borrowed from BTeach Smart Class\n  The right subtree is too high, and the right child has a right child. In this case, Left Rotation operation is used to rotate the nodes one position to the left.   The left subtree is too high, and the left child has a left child. Right Rotation is used in this case to rotate nodes one position to the right.   The right subtree is too high, and the right child has a left child. This case requires double rotation operations called Right Left Rotation. At first, Right Rotation will be performed at the right node of given node, then a Left Rotation will be used at the given node.   The left subtree is too high, and the left child has a right child. Right Left Rotation operation will be used in this case.   Insertion Operation in AVL Tree A new element is inserted to an AVL tree in the same logic as to a BST. However, balance factor of each node is updated and checked after insertion. The tree is said to be imbalanced if the balance factor of any node is other than 0, 1 or -1. In that case, suitable rotation operation is used to re-balance the tree.\nIt can be shown that a height-balanced tree with n nodes has height O(log(n)). Since the cost of our algorithms is proportional to the height of the tree, each operation (lookup, insertion or deletion) will take time O(log(n)) in the worst case.\nExample - Construct an AVL tree by inserting numbers from 1 to 8\nImplementation We define a type Node with following fields: value, its left and right nodes, and its balance value.\ntype Node struct { Value int // value of a node \tLeft *Node // left node \tRight *Node // right node \tBal int // Bal = h_left - h_right } Insert() first inserts a given data to an existing AVL subtree at node n, then rebalances the subtree if needed by calling helper function Rebalance().\nfunc (n *Node) Insert(data int) { // Node already exists, do no change \tif data == n.Value { fmt.Println(\u0026#34;Node already exists\u0026#34;) return } // If data is less than value of Node c, traverse to the left. \t// Otherwise, traverse to the right \tif data \u0026lt; n.Value { // Left node does not exist. Create a new one \tif n.Left == nil { n.Left = \u0026amp;Node{Value: data} // Update Balance Factor of Node n \tn.Bal++ return } a := n.Left.Bal n.Left.Insert(data) // Check whether the tree\u0026#39;s height has changed after inserting \tif n.Left.Bal != 0 \u0026amp;\u0026amp; n.Left.Bal != a { if n.Left.Bal \u0026lt; -1 || n.Left.Bal \u0026gt; 1 { n.Rebalance(n.Left) } else { n.Bal++ } } return } if n.Right == nil { n.Right = \u0026amp;Node{Value: data} n.Bal-- return } b := n.Right.Bal n.Right.Insert(data) if n.Right.Bal != 0 \u0026amp;\u0026amp; n.Right.Bal != b { if n.Right.Bal \u0026lt; -1 || n.Right.Bal \u0026gt; 1 { n.Rebalance(n.Right) } else { n.Bal-- } } return } Rebalance() performs suitable rotation operation to make a subtree balanced by calling either LLRotation(), RRRotation(), LRRotation(), or RLRotation()\nfunc (n *Node) Rebalance(c *Node) { fmt.Printf(\u0026#34;Re-Balance @ node %v \\n\u0026#34;, c.Value) // Left subtree is too high, and left child has a left child. \tif c.Bal == 2 \u0026amp;\u0026amp; c.Left.Bal == 1 { n.RRRotation(c) return } // Right subtree is too high, and right child has a right child. \tif c.Bal == -2 \u0026amp;\u0026amp; c.Right.Bal == -1 { n.LLRotation(c) return } // Left subtree is too high, and left child has a right child. \tif c.Bal == 2 \u0026amp;\u0026amp; c.Left.Bal == -1 { n.LRRotation(c) return } // Right subtree is too high, and right child has a left child. \tif c.Bal == -2 \u0026amp;\u0026amp; c.Right.Bal == 1 { n.RLRotation(c) return } } func (n *Node) LLRotation(c *Node) { r := c.Right // create a temporary node r to hold node c.Right \tc.Right = r.Left // make left children of r become right children of c \tr.Left = c // make c as r left child \t// Update balance factor of node c and r \tif c.Left != nil \u0026amp;\u0026amp; c.Right == nil { c.Bal = 1 } else { c.Bal = 0 } r.Bal = 0 // Let parent node n point to new node r \tif c == n.Left { n.Left = r } else { n.Right = r } } func (n *Node) RRRotation(c *Node) { l := c.Left c.Left = l.Right l.Right = c if c.Right != nil \u0026amp;\u0026amp; c.Left == nil { c.Bal = -1 } else { c.Bal = 0 } l.Bal = 0 if c == n.Left { n.Left = l } else { n.Right = l } } func (n *Node) LRRotation(c *Node) { c.LLRotation(c.Left) n.RRRotation(c) } func (n *Node) RLRotation(c *Node) { c.RRRotation(c.Right) n.LLRotation(c) } A tree can either be empty or has a node. Each node in a tree has left and right subtrees. If a tree is empty, inserting an element to the tree is creating a root node.\nPerforming insertion to a tree has to take care of re-balancing the root node if the tree is imbalanced at root node. The root node has no parent, to be unable to use node\u0026rsquo;s rebalance method above a fake parent node is created. This node stores value -1, and root node is its either left child or right child.\ntype AVLTree struct { Root *Node } // Insertion func (t *AVLTree) Insert(data int) { if t.Root == nil { t.Root = \u0026amp;Node{Value: data} return } t.Root.Insert(data) // Check whether the root node gets out of balance \tif t.Root.Bal \u0026lt; -1 || t.Root.Bal \u0026gt; 1 { t.rebalance() } } func (t *AVLTree) rebalance() { rootParent := \u0026amp;Node{Left: t.Root, Value: -1} rootParent.Rebalance(t.Root) t.Root = rootParent.Left } print() will print the tree with displaying nodes' heights\nfunc (t *AVLTree) print(n *Node, height int) { if n == nil { return } format := \u0026#34;--[\u0026#34; t.print(n.Right, height+1) fmt.Printf(\u0026#34;%*s%d(%v)\\n\u0026#34;, 7*(height+1), format, n.Value, n.Bal) t.print(n.Left, height+1) } Now let\u0026rsquo;s go through an example of contructing an AVL Tree by inserting numbers from 1 to 6\nfunc main() { values := []int{1, 2, 3, 4, 5, 6} t := \u0026amp;AVLTree{} for i := 0; i \u0026lt; len(values); i++ { fmt.Printf(\u0026#34;Insert %v--------------------------\\n\u0026#34;, values[i]) t.Insert(values[i]) t.print(t.Root, 0) fmt.Println() } } Here\u0026rsquo;s the result: References  AVL Tree from BTech Smart Class Balanced BST from cs.ecu.edu Trees from sc.ecu.edu  ","href":"/docs/balancedbst/","title":"Balanced Binary Search Tree - AVL Tree"},{"content":"","href":"/tags/balanced-bst/","title":"Balanced BST"},{"content":"","href":"/tags/bst/","title":"BST"},{"content":"","href":"/categories/","title":"Categories"},{"content":"","href":"/tags/example/","title":"example"},{"content":"","href":"/categories/features/","title":"features"},{"content":"","href":"/tags/go/","title":"go"},{"content":"","href":"/tags/golang/","title":"golang"},{"content":"","href":"/tags/","title":"Tags"},{"content":"","href":"/authors/tracey/","title":"tracey"},{"content":"Source code\nFetch maximum value Maximum value of a BST is the value of the most right node\nfunc FetchMax(t *treeNode) int { if t.Right == nil { return t.Value } return FetchMax(t.Right) } Return value: 14\nFetch minimum value Minimum value of a BST is the value of the most left node\nfunc FetchMin(t *treeNode) int { if t.Left == nil { return t.Value } return FetchMin(t.Left) } Return: 1\nGet Height Helper functions: GetHeightLeaves and max\nfunc (t *treeNode) GetHeight(leaves []int) int { return max(leaves) } func (t *treeNode) GetHeightLeaves(height int, leaves *[]int) []int { if t.Left == nil \u0026amp;\u0026amp; t.Right == nil { *leaves = append(*leaves, height) } else { height++ if t.Left != nil { t.Left.GetHeightLeaves(height, leaves) } if t.Right != nil { t.Right.GetHeightLeaves(height, leaves) } } return *leaves } func max(arr []int) int { max := arr[0] for _, v := range arr { if max \u0026lt; v { max = v } } return max } One can also store an information about height in type node. In that case, height of a node is the maximum height between left subtree and right subtree plus one.\nheight = 1 + max(height_left, height_right) Print a tree func (t *treeNode) print(height int) { if t == nil { return } format := \u0026#34;--[\u0026#34; t.Right.print(height + 1) fmt.Printf(\u0026#34;%*s%d\\n\u0026#34;, 7*(height+1), format, t.Value) t.Left.print(height + 1) } That is what will be displayed.\nGet all values with the same level from BST While the function BreadthFirstTraversal returns an array of tree\u0026rsquo;s values by levels, the GetLevel function returns a map, where map\u0026rsquo;s keys are tree\u0026rsquo;s levels, and map\u0026rsquo;s values are arrays of all the nodes' values on each level.\ntype levelValue map[int][]int func (t *treeNode) GetLevel(level int, m *levelValue) levelValue { (*m)[level] = append((*m)[level],t.Value) if t.Left == nil \u0026amp;\u0026amp; t.Right == nil { return *m } level = level + 1 if t.Left == nil { return t.Right.GetLevel(level, m) } if t.Right == nil { return t.Left.GetLevel(level, m) } t.Left.GetLevel(level, m) t.Right.GetLevel(level, m) return *m } Such as\n Level 0: 8 Level 1: 3 10 Level 2: 1 6 14 Level 3: 4 7 13  Print left view of BST Left view of a Binary Tree is a set of nodes visible when tree is visited from left side.\nfunc (t *treeNode) printLeftView(root *treeNode) { if t == nil { return } fmt.Println(t.Value) left(root) } func left(t *treeNode) { if t == nil { return } if t.Left != nil { fmt.Println(t.Left.Value) } left(t.Left) left(t.Right) } Return: 8 3 1 4 13\nFind Inorder predecessor and successor for a given key in BST In a given BST highest element on the left subtree is the Predecessor and lowest element on the right subtree is the Successor of the given node.\n1. Finding Predecessor\n// Find Inorder predecessor successor for a given key in BST // Return -1 if there is not any func (t *treeNode) FindPredecessor(key int) int { if t == nil { panic(\u0026#34;root is nil\u0026#34;) } node := t.nodeSearch(key) if node == nil { panic(\u0026#34;key does not exist in the tree\u0026#34;) } parent := t.parent(node) if node.Left == nil { if node.Value == t.Value { return -1 } if node.Value \u0026lt; t.Value { if node.Value \u0026lt; parent.Value { return -1 } return parent.Value //panic(\u0026#34;No predecessor\u0026#34;)  } if node.Value \u0026gt; t.Value { if node.Value \u0026gt; parent.Value { return parent.Value } return t.parent(parent).Value } } return FetchMax(node.Left) } // Find parent node for a given node in BST func (t *treeNode) parent(node *treeNode) *treeNode { if t == nil { fmt.Println(\u0026#34;Tree does not exist\u0026#34;) return nil } if t == node { fmt.Println(\u0026#34;Node is root node, that has no parent\u0026#34;) return nil } if node.Value \u0026lt; t.Value { if t.Left == node { return t } return t.Left.parent(node) } if t.Right == node { return t } return t.Right.parent(node) } 2. Finding Successor\n// Find Inorder successor for a given key in BST func (t *treeNode) FindSuccessor(key int) int { if t == nil { panic(\u0026#34;root is nil\u0026#34;) } node := t.nodeSearch(key) if node == nil { panic(\u0026#34;key does not exist in the tree\u0026#34;) } parent := t.parent(node) if node.Right == nil { if node.Value == t.Value { return -1 } if node.Value \u0026gt; t.Value { //panic(\u0026#34;No successor\u0026#34;)  if node == parent.Right { return -1 } return parent.Value } if node.Value \u0026lt; t.Value { if node == parent.Left { return parent.Value } return t.parent(parent).Value } } return FetchMin(node.Right) } References  Binary Trees  ","href":"/docs/bst-others/","title":"Binary Search Tree - Part III"},{"content":"Source code\nA traversal is a process of visiting all the nodes in a tree. We can categorise tree\u0026rsquo;s traversal algorithms into 2 groups: depth-first traversal and breadth-first traversal.\n Depth-first traversal: includes PreOrder traversal, InOrder traversal, and PostOrder traversal. Breadth-first traversal: the level order traversal. In this traversal, we visit the node by levels from top to bottom, and from left to right.  Let have a look at implementations of those traversal.\nPreOrder traversal  Visit root node Visit all the nodes in the left subtree Visit all the nodes in the right subtree  func (t *treeNode) PreorderTraversal() { if t == nil { return } fmt.Println(t.Value) t.Left.PreorderTraversal() t.Right.PreorderTraversal() } Return: 8 3 1 6 4 7 10 14 13\nInOrder traversal  First, visit all the nodes in the left subtree Then the root node Visit all the nodes in the right subtree  func (t *treeNode) InOrderTraversal() { if t == nil { return } t.Left.InOrderTraversal() fmt.Println(t.Value) t.Right.InOrderTraversal() } Return: 1 3 4 6 7 8 10 13 14\nPostOrder traversal  Visit all the nodes in the left subtree Visit all the nodes in the right subtree Visit the root node  func (t *treeNode) PostOrderTraversal() { if t == nil { return } t.Left.PostOrderTraversal() t.Right.PostOrderTraversal() fmt.Println(t.Value) } Return: 1 4 7 6 3 13 14 10 8\nBreadth first traversal func (t *treeNode) BreadthFirst() []int { if t == nil { return nil } var queue []*treeNode queue = append(queue, t) var res []int res = levelOrder(queue, res) fmt.Println(res) return res } func levelOrder(queue []*treeNode, res []int) []int { if len(queue) == 0 { return res } n := len(queue) for i := 0; i \u0026lt; n; i++ { res = append(res, queue[i].Value) if queue[i].Left != nil { queue = append(queue, queue[i].Left) } if queue[i].Right != nil { queue = append(queue, queue[i].Right) } } return levelOrder(queue[n:], res) } Return: 8 3 10 1 6 14 4 7 13\nReferences  Binary Trees  ","href":"/docs/traverse-bst/","title":"Binary Search Tree - Part II"},{"content":"","href":"/tags/breadth-first-traversal/","title":"breadth-first traversal"},{"content":"","href":"/tags/depth-first-traversal/","title":"depth-first traversal"},{"content":"","href":"/tags/traverse/","title":"traverse"},{"content":"Source code\nIntroduction A Binary Tree is a tree data structure, that consists of nodes. The topmost node in the tree is the root. Every node in a Binary Tree has maximum 2 children, which are referred to as left and right child. A leaf is a node that both its left and right subtrees are empty. A node with only one subtree is called half-leaf. A parent of a node is the node immediately above it.\ntype treeNode struct { Left *treeNode Right *treeNode Value int } A common operations in a binary tree are searching, insertion, and deletion. To perform those operations in binary search tree, we need to traverse all elements of the tree. Therefore, in the worst case, the time complexity of those opereation is O(n).\nA Binary Search Tree (BST) is a binary tree where values of the left node and right node are less than and greater than value of its parent, correspondingly.\nOperations in BST has time complexity is O(h), where h is height of the BST. In the worst case where h is equal number of elements in the tree, the worst case complexity is O(n). A BST that is built from a sorted list of keys will produce worst case performance.\nSearching an element from BST Searching for an element from BST is performed by comparing the search element with the value of root node.\n If both are matched, then return the root node; If search element is smaller, continue searching on the left subtree; If search element is larger, continue searching on the right subtree; If there is no such element found, display \u0026ldquo;Element is not found\u0026rdquo;.  func (t *treeNode) nodeSearch(data int) *treeNode { if t == nil { fmt.Println(\u0026#34;Tree is empty\u0026#34;) return nil } if data == t.Value { return t } if data \u0026lt; t.Value { if t.Left == nil { fmt.Println(\u0026#34;Element is not found\u0026#34;) return nil } return t.Left.nodeSearch(data) } if t.Right == nil { fmt.Println(\u0026#34;Element is not found\u0026#34;) return nil } return t.Right.nodeSearch(data) } Insert an element to BST Inserting an element to a BST with the same logic as searching for an element. It is noted that the element is inserted to a leaf node only.\nfunc (t *treeNode) Insert(data int) { if t == nil { t = \u0026amp;treeNode{Value: data} return } if data == t.Value { fmt.Println(\u0026#34;Node already exists\u0026#34;) return } if data \u0026lt; t.Value { if t.Left == nil { t.Left = \u0026amp;treeNode{Value: data} return } t.Left.Insert(data) return } if data \u0026gt; t.Value { if t.Right == nil { t.Right = \u0026amp;treeNode{Value: data} return } t.Right.Insert(data) } } Delete Node  Node to be deleted is a leaf: Removing this node from the tree by setting its parent points to nil. Node to be deleted is half leaf: setting its parent points to its child Node to be deleted has two children:  Find inorder successor of the node; Copy contents of the inorder successor to the node; Delete the inorder successor.    It is noted that inorder predecessor can also be used.\n/* ------------------------------------------------------------------------------ DELETE Delete a node from BST Helper functions: PointToNil and transplant ---------------------------------------------------------------------------------*/ func (t *treeNode) DeleteNode(root *treeNode, data int) { if root == nil { return } node := root.nodeSearch(data) if node == nil { panic(\u0026#34;key does not exist in the tree\u0026#34;) } parent := t.parent(node) // delete leaf \tif node.Left == nil \u0026amp;\u0026amp; node.Right == nil { PointToNil(node, parent) return } if node.Left == nil { t.transplant(node, node.Right) return } if node.Right == nil { t.transplant(node, node.Left) return } nodeSuccessor := root.FindSuccessor(data) node.Value = nodeSuccessor root.DeleteNode(node.Right, nodeSuccessor) return } func PointToNil(node, parent *treeNode) { if node == parent.Left { parent.Left = nil return } if node == parent.Right { parent.Right = nil return } } func (t *treeNode) transplant(n1, n2 *treeNode) { parent := t.parent(n1) // n1 is root \tif parent == nil { t.Value = n2.Value t.Right, t.Left = n2.Right, n2.Left return } if n1 == parent.Left { parent.Left = n2 return } if n1 == parent.Right { parent.Right = n2 return } } Finding Successor\nHelper function is parent()\n// Find Inorder successor for a given key in BST func (t *treeNode) FindSuccessor(key int) int { if t == nil { panic(\u0026#34;root is nil\u0026#34;) } node := t.nodeSearch(key) if node == nil { panic(\u0026#34;key does not exist in the tree\u0026#34;) } parent := t.parent(node) if node.Right == nil { if node.Value == t.Value { return -1 } if node.Value \u0026gt; t.Value { //panic(\u0026#34;No successor\u0026#34;)  if node == parent.Right { return -1 } return parent.Value } if node.Value \u0026lt; t.Value { if node == parent.Left { return parent.Value } return t.parent(parent).Value } } return FetchMin(node.Right) } // Find parent node for a given node in BST func (t *treeNode) parent(node *treeNode) *treeNode { if t == nil { fmt.Println(\u0026#34;Tree does not exist\u0026#34;) return nil } if t == node { fmt.Println(\u0026#34;Node is root node, that has no parent\u0026#34;) return nil } if node.Value \u0026lt; t.Value { if t.Left == node { return t } return t.Left.parent(node) } if t.Right == node { return t } return t.Right.parent(node) } For example, deleting a leaf node - Node 1\nDeleting a half node - Node 14\nDeleting a full node - Node 6\nDeleting root node - Node 8\nReferences  Binary Trees  ","href":"/docs/bst/","title":"Binary Search Tree - Part I"},{"content":"","href":"/tags/api/","title":"API"},{"content":"","href":"/tags/game/","title":"game"},{"content":"","href":"/tags/gcp/","title":"GCP"},{"content":"Source code\nDescription This simple game is modified from Flappy Gopher game from Ebiten. It is written in Go using Ebiten library.\nMira is running her scooter. She is going to meet objects on her way, and jumping over them is the only way to go pass. Every time when she successfully avoids an object she will get one point.\nHow to play Press space key or left-click when you want to jump.\nSome modifications that have been made  Changing Gopher image to Mira image. The new image is stored locally in personal github folder  localsrc \u0026#34;github.com/tracey7d4/mirajump/resources/images  Un-rotating image during jumping period Deleting upper pipes Increasing gap between two adjacent pipes Making pipes' height fixed Changing to automatically running on the ground Jumping only once at a time. Another jump can only be done as long as Mira is on the ground.  ","href":"/project/mirajump/","title":"Mira Jump"},{"content":"","href":"/tags/project/","title":"project"},{"content":"Source code\nIn this application, we will discuss about stockbot that returns stock prices of a company. The architecture is as follows.\nFor one who comes to this repository first, I have another repository call weatherbot in which I have described step by step how to build a weatherbot for querying weather conditon of a location. Most of the steps of implementation for two bots are similar, including building a Slack bot user, subscribing to app mentioned event, creating a Go function which is a HTTP handler. So please refer to that application for more details. In this application, I only discuss the difference in Go function. In particular, we will have a look at getStock(), which is used to make a call out to third-party API, receive the response, extract and format the information.\nThe getQuote() is as follows.\nfunc getQuote(sym string) (string, error) { sym = strings.ToUpper(sym) fhUrl := fmt.Sprintf(\u0026#34;https://finnhub.io/api/v1/quote?symbol=%s\u0026#34;, sym) resp, err := http.Get(fhUrl) if err != nil { return \u0026#34;\u0026#34;, err } defer func(){ _ = resp.Body.Close() }() body, err := ioutil.ReadAll(resp.Body) m := make(map[string]float32) err = json.Unmarshal(body, \u0026amp;m) if err != nil { return \u0026#34;\u0026#34;, err } fhUrlForName := fmt.Sprintf(\u0026#34;https://finnhub.io/api/v1/stock/profile2?symbol=%s\u0026#34;, sym) resp, err = http.Get(fhUrlForName) if err != nil { return \u0026#34;\u0026#34;, err } defer func(){ _ = resp.Body.Close() }() body, err = ioutil.ReadAll(resp.Body) m1 := make(map[string]string) err = json.Unmarshal(body, \u0026amp;m1) if err != nil { return \u0026#34;\u0026#34;, err } var s string if len(m) == 1 { s = \u0026#34;_\u0026#34; + sym + \u0026#34; is not a valid trading name_\u0026#34; } else { s = \u0026#34;*\u0026#34; + m1[\u0026#34;name\u0026#34;] + \u0026#34; (\u0026#34; + sym + \u0026#34;) \u0026#34; + \u0026#34; Stock Price* \\n\u0026#34; + \u0026#34;_current_: $\u0026#34; + fmt.Sprintf(\u0026#34;%.2f\u0026#34;, m[\u0026#34;c\u0026#34;]) + \u0026#34;\\n\u0026#34; + \u0026#34;_high_: $\u0026#34; + fmt.Sprintf(\u0026#34;%.2f\u0026#34;, m[\u0026#34;h\u0026#34;]) + \u0026#34;\\n\u0026#34; + \u0026#34;_low_: $\u0026#34; + fmt.Sprintf(\u0026#34;%.2f\u0026#34;, m[\u0026#34;l\u0026#34;]) + \u0026#34;\\n\u0026#34; + \u0026#34;_open_: $\u0026#34; + fmt.Sprintf(\u0026#34;%.2f\u0026#34;, m[\u0026#34;o\u0026#34;]) + \u0026#34;\\n\u0026#34; + \u0026#34;_previous close_: $\u0026#34; + fmt.Sprintf(\u0026#34;%.2f\u0026#34;, m[\u0026#34;pc\u0026#34;]) + \u0026#34;\\n\u0026#34; + \u0026#34;_timestamp_: \u0026#34; + time.Now().UTC().String() } return s, nil } I use http://finnhub.io API this time for getting stock value of a company by its ticker symbol. You can find its API documentation in here.\nI also want to display the company trading name along with its ticker symbol, so I make another call for getting the company name.\nhttps://finnhub.io/api/v1/stock/profile2?symbol=\u0026lt;ticker symbol\u0026gt; Now let\u0026rsquo;s deploy our Go function\ngcloud functions deploy AppStockMentionHandler --runtime go111 --trigger-http\rWhen you see that your function has been successfully deployed, go to a Slack Channel and call your bot, remember to mention its name.\n@stockbot aapl\rHope you enjoy your bots.\nAPI reference  Stock API Documentation Weather bot repository  ","href":"/project/stockbot/","title":"Simple Slack bot in Go using event API - Stock Bot"},{"content":"","href":"/tags/slack/","title":"slack"},{"content":"Source code\nIn this repository, I\u0026rsquo;m going to create a weatherbot for querying weather condition of a given location. The idea of writing a Slack bot in Go was inspired by rapidloop\u0026rsquo;s slackbot for RTM API. At the moment, Slack platform provides a range of APIs that Slack apps can access to including events API, web API, Audit Logs APIs beside RTM API which was used in rapidloop\u0026rsquo;s implementation. As RTM API is being phased out in favour of events API, in this application, events API will be used.\nArchitecture The architecture of the application can be seen in the diagram below.\nWhen a bot is mentioned in Slack App, an event is created on Slack Event API. That event will trigger a call out to a cloud function.The cloud function was written in Go and hosted on Google Cloud Platform (GCP). The function gets the location from the request, calls out to a third-party API, which is openweathermap in this case, to get the weather information. The function then formats the final message with that information before sending it back to Slack API to display in Slack App.\nCreating such bot required the following steps\n  Build a Slack Bot User that subscribes to app_mention event\n  Create a project on GCP to deploy the cloud function.\n  Create a Go function which is a HTTP handler that responds to events triggered by Slack bot\n  Implementation   Build a Slack Bot User\nIt will need a Slack workspace as well to deploy the bot. So either an existing workspace or a new one is required. In Slack API page, let\u0026rsquo;s create a new app by clicking on the Create New App button. Next, create a Bot User for it. Invite your bot to Slack channels where you want to interact with it. Follow the link for more details about bot users and how to build one.\nWe also need to subscribe to app_mention event. This subscription allows your bot to response to users' requests that mention its name.\n  Create a project on GCP\nA GCP account is all we need to create a Project on GCP. Follow the instruction of setting up a GCP Project here.\n  Create a Go function\nThe final step is writing a Go function for your bot that will be deployed on to GCP. If you haven\u0026rsquo;t worked with GCP before, there is an example of Hello, World cloud function in the link given above, which can serve as an excellent starting point.\nOur Go function is routed with each request made to the cloud function, and a response to an incoming request will be written to the http.ResponseWriter. More details on this will be provided in a later section.\nTo make our bot respond to the request when its name is mentioned, we need to subscribe to the app_mention event.\nA. Event Subscription\nGo to Your Apps at https://api.slack.com/apps, choose the bot, go to Event Subscription configuration under Features section, then turn Enable Events to On.\nAn Event Request URL must be confirmed before subscribing to any events and saving the form. Right after you type in a URL, Slack will automatically send out an attribution that includes token, challenge, and type fields as shown in figure below. It is noted that this figure is taken from Slack usages guide. Yours will look different.\nThe requirement is that our endpoint will respond back with challenge attribute value. In other words, our function needs to catch the challenge value and send it back to Slack for the first time running. Following is the function that performs the task.\nfunc AppWeatherMentionHandler(w http.ResponseWriter, r *http.Request) { // get the request body  defer func() { _ = r.Body.Close() }() body, _ := ioutil.ReadAll(r.Body) m := make(map[string]interface{}) err := json.Unmarshal(body, \u0026amp;m) if err != nil { _, _ = fmt.Fprintf(w, \u0026#34;error unmarshalling body: %v\u0026#34;, err) return } fmt.Fprintf(w, \u0026#34;%s\u0026#34;, m[\u0026#34;challenge\u0026#34;]) } Deploy this function by following command\ngcloud functions deploy AppWeatherMentionHandler --runtime go111 --trigger-http\rAnswer y to the question about unauthenticated access. In the returning log you can see the URL that points to your newly created cloud function as an endpoint for your web service. Copy and paste this link to the Request URL panel on web Slack app till the field turned to Verified\nOnce the URL is successfully verified, click on Add Bot User Event, choose app_mention event and then save the form Save changes.\nWe have already done with subscribing an event for our bot. Now come back with our Go function for weatherbot.\nB. Slack Weather Bot\nOur Go function AppWeatherMentionHandler() is a HTTP handler that does the following tasks\n Get the city name from the JSON payload describing the event and assign it to a variable city; Call a local function getWeather() to get weather message;  get the weather from openweathermap format the return message   Call sendMessage() function to display the response in Slack channels.  In the first step, the JSON payload from Slack API will look like this.\n\u0026#34;token\u0026#34;: \u0026#34;*****************************\u0026#34;, \u0026#34;team_id\u0026#34;: \u0026#34;**************\u0026#34;, \u0026#34;api_app_id\u0026#34;: \u0026#34;********\u0026#34;, \u0026#34;event\u0026#34;: { \u0026#34;client_msg_id\u0026#34;: \u0026#34;************************\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;app_mention\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;\u0026lt;@ your bot user_ID\u0026gt; Melbourne, Au\u0026#34;, \u0026#34;user\u0026#34;: \u0026#34;************\u0026#34;, \u0026#34;ts\u0026#34;: \u0026#34;1592101177.000800\u0026#34;, .... We\u0026rsquo;re going to unmarshall this JSON into a map to extract the information of interest. Apart from the city name I also need the token and channel fields as they are required to send the message back to Slack later.\nbody, _ := ioutil.ReadAll(r.Body) m := make(map[string]interface{}) err := json.Unmarshal(body, \u0026amp;m) if err != nil { _, _ = fmt.Fprintf(w, \u0026#34;error unmarshalling body: %v\u0026#34;, err) return } m1 := m[\u0026#34;event\u0026#34;].(map[string]interface{}) text := fmt.Sprintf(\u0026#34;%v\u0026#34;, m1[\u0026#34;text\u0026#34;]) str := strings.Split(text, \u0026#34;\u0026lt;bot user ID\u0026gt;\u0026#34;) city := strings.Trim(str[1], \u0026#34; \u0026#34;) channel := fmt.Sprintf(\u0026#34;%v\u0026#34;, m1[\u0026#34;channel\u0026#34;]) token := \u0026#34;User\u0026#39;s Slack Bot Token\u0026#34; Call getWeather() with city variable as an input.\nweather, err := getWeather(city) I am using openweathermap.org API to get weather information. This API requires an appID, and all you need to do to get one is signing up an account on its website. You can check API documentation for current weather here. To get current weather of a city by name with returned values in cubic metric you need to call the following endpoint.\nhttp://api.openweathermap.org/data/2.5/weather?q=\u0026lt;city_name\u0026gt;\u0026amp;units=metric\u0026amp;APPID=\u0026lt;appID\u0026gt; If the data for that city could not be found, {\u0026quot;cod\u0026quot;:\u0026quot;404\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;city not found\u0026quot;} is returned. In this case, our bot will display City \u0026lt;city_name\u0026gt; is not found to the user. Otherwise, weather information will be extracted from the response and put into a formatted Slack message, which will subsequently be sent back to Slack when calling sendMessage().\nerr = sendMessage(token, channel, weather) if err != nil { fmt.Fprintf(w, \u0026#34;error: %v\u0026#34;, err) } As Slack supports formatting text object, the message can be prettied by using some special symbols such as * (for Bold), _ (for Italic). I even created an emojimap to add some weather emoji icons.\nOur AppWeatherMentionHandler function is now ready to deploy to GCP.\ngcloud functions deploy AppWeatherMentionHandler --runtime go111 --trigger-http\rOnce it is successfully deployed, you can try the bot out on your Slack channel. For instance, if you want to know how the weather at Melbourne, Australia is, you mention your bot like follows.\n@weatherbot Melbourne, Au\rAnd this is what will be displayed in your Slack channel\n  Conclusion Well done! Now you have a working bot handy for checking weather. Follow this link for another amazing bot that allows you to quote stock price.\nReferences  Rapid loop slackbot for RTM API Slack API Slack Event API Google Cloud Platform openweathermap API Create a Slack App Slack Bot users App_mention event GCP cloud function example Current Weather API doc Formatting Text Weather condition Emoji Golang http Markdown Basic writting and formatting on Gibthub Stockbot repository Icons made by Dave Gandyfrom www.flaticon.com  ","href":"/project/weatherbot/","title":"Simple Slack bot in Go using event API - Weather Bot"},{"content":"","href":"/tags/channel/","title":"channel"},{"content":"","href":"/tags/concurrency/","title":"concurrency"},{"content":"Source code\nI found that it is an excellent example about Go concurrency and synchronization.\nProblem description There are 5 philosophers having their dinner at a round table with one chopstick between each adjacent pair of philosophers. A philosopher can only eat when they have both left and right chopsticks. In other words, while one philosopher is eating, his two adjacent friends have to wait. After eating he puts both chopsticks down to let the others eat. Under problem constraint, there is a limit number of philosophers that can eat concurently. And this number may differ in range of 1 to as many as possible.\nThe deadlock may occur when each philosopher simultaneously pickups one chopstick and waits for another chopticks forever.\nA host which executes in its own goroutine is introduced to resolve the deadlock situation. The host plays a role on coordinating the dining process. In order to give a philosopher permission to eat, host needs to check for all the required conditions, including current status of two adjacent of that philosopher and how many philosophers are eating at that time.\nImplementation Note: This design is scalable, i.e number of philosophers, number of courses per Philosopher, and number philosophers that eat concurrently can be changed.\nconst ( noP = 5 //number of Philosophers \tnoCoursesPerP = 3 // Number of courses per Philosophers \tnoPEatAtOneTime = 2 // number of Philosophers eating concurrently ) We use goroutines to let functions run concurrently, and channels to communicate among goroutines. Firstly, to make sure only one Philosopher can access left and right chopticks at a time, we use sync.Mutex that allows Philosopher locking the resources while eating and unlocking them after finishing eating. Secondly, we use sync.WaitGroup to wait for all goroutines to finish before main goroutine executes. Afer finishing its task, a goroutine will notify the WaitGroup that it\u0026rsquo;s done wg.Done(). The WaitGroup counter increases by one wg.Add(1) everytime a goroutine is launched, and decreases by one everytime receiving notification wg.Done() from a goroutine. So the WaitGroup counter will go back to 0 until all the goroutines notify they\u0026rsquo;re done.\nWe create 3 new types: Chopstick, Philosopher, and Host as follows\ntype Chopstick struct { sync.Mutex } type Philosopher struct { id int leftCS *Chopstick rightCS *Chopstick permission \u0026lt;-chan bool notifyHostIAmDone chan\u0026lt;- int courses int } type Host struct { totalCourses int //so host knows when to stop while all P have finished all courses \tPStatus map[int]Status noEating int pFinishedEating \u0026lt;-chan int } Next, we define method for each type. In particular, the type Philosopher with an eatmethod, and type Host with coordinate method have been declared as follows\nfunc (p *Philosopher) eat(wg *sync.WaitGroup) { for p.courses \u0026gt; 0 { // get permission from Host \t\u0026lt;-p.permission // lock the resources \tp.leftCS.Lock() p.rightCS.Lock() // process: eating --- finishing \tfmt.Printf(\u0026#34;P %v started eating\\n\u0026#34;, p.id) p.courses-- time.Sleep(10 * time.Millisecond) fmt.Printf(\u0026#34;P %v finished eating. Remaining courses %v\\n\u0026#34;, p.id, p.courses) //unlock the resources \tp.leftCS.Unlock() p.rightCS.Unlock() //notify Host \tp.notifyHostIAmDone \u0026lt;- p.id } // finished all course \twg.Done() } func (h *Host) coordinate(wg *sync.WaitGroup) { for h.totalCourses \u0026gt; 0 { select { case id := \u0026lt;-h.pFinishedEating: m := h.PStatus[id] m.eating = false h.PStatus[id] = m h.totalCourses-- h.noEating-- default: h.letThemEat() } } wg.Done() } Each time a Philosopher finishes eating, he will notify the host by sending out his ID, so that the host can update his status. Status is a type that contains several fields as follows\ntype Status struct { eating bool courses int eatingPermission chan\u0026lt;- bool } After giving eating permission to a Philosopher, the host once again updates the status of that Philosopher. At the result, the host know the status of all Philosopher at a current of time, so that he can coordinate the dining process.\n","href":"/docs/dining-philosopher/","title":"Dining Philosopher problem in Go"},{"content":"","href":"/tags/config/","title":"Configuration"},{"content":"","href":"/tags/og/","title":"Opengraph"},{"content":"","href":"/page/","title":"Pages"},{"content":"","href":"/search/","title":"Search"},{"content":"","href":"/series/","title":"Series"}]
