[{"content":" This blog is about Go by examples.\n ","href":"/","title":"Home"},{"content":"","href":"/docs/","title":"My Posts"},{"content":"","href":"/project/","title":"My Projects"},{"content":"Hello, I\u0026rsquo;m Tracey. I am a self-taught software engineer with applied mathematics background. After going through A Tour of Go, I found that Go was actually a neat and simple language to learn and started to develop more interest in programming. While still in my learning journey, I create this blog to share interesting problems and projects that I have done in Go, as well as some other useful resources.\nHope you like the blog and happy Go-ing!\n","href":"/about/","title":"About"},{"content":"Courses  A Tour of Go\nA tour that covers most important features of the Go language Programming with Google Go Specialization\nThis course introduces the Go language and provides you with Go\u0026rsquo;s features. This specialization is from Coursera and offered by University of California, Irvine (UCI) Data Structures and Algorithms Specialization\nData Structures and Algorithms Courses from Coursera offered by University of California San Diego \u0026amp; National Research University Higher School of Economics  Books  Cracking the Coding Interview by Gayle Laakmann McDowell Learning Algorithms through programming and puzzle solving by Alexander Kulikov and Pavel Pevzner  Resources  sync.RWMutex\nA nice write up of how to use sync.RWMutex to handle concurrent read/write access to shared resources HackerRank\nA website where you can practice your programming skills w3schools.com  ","href":"/resources/","title":"Resources"},{"content":"","href":"/authors/","title":"Authors"},{"content":"","href":"/categories/","title":"Categories"},{"content":"Source code\nDescription Given an array arr of n integers (n \u0026gt; 0). Our program is to check whether it is possible to divide the given array into three sets with equal sums.\nFor example, Array arr = {1, 1, 2, 2, 3, 3} can be divided into 3 subsets with equal sum = 4 as follows: {1, 3}, {1, 3} and {2, 2}; while array arr = {1, 1, 2} can not be divided into such 3 subsets.\nImplementation Let\u0026rsquo;s have a look at several cases:\n  When length of given array is less than 3: it\u0026rsquo;s impossible to divide it into 3 subsets, and in that case, program returns false\n  If the total value of all elements in the given array is not divided by 3, return false\n  Otherwise, go further to check all the possibilities.\nLet\u0026rsquo;s think about a smaller problem that is checking the possibility P(arr, k) of forming a subset from a given array that elements sum up to a target number k. To do so, we will need to recursively check the possibility of including the element arr[i] to the subset P(arr,k) = P(arr, k-arr[i]). Our base case is when k == 0 stated that we have reached to target value. In case there is no more element in the given array while we have not yet reached to target value (when we have use all elements in given array but not yet reached to the targer), return value is false.\nCome back to our three subsets problem, we will need to form 3 such subsets instead of one. It is noted that 3 subsets are formed simultaneously, not separately. The base case is when all subsets have reached to their target values k1 == 0 \u0026amp;\u0026amp; k2 == 0 \u0026amp;\u0026amp; k3 == 0.\nWe will cache the overlapping case using a map, where key is a string formed form from k1, k2, k3 and length of the input array.\n  func partitionArray(arr []int) bool { n := len(arr) sum := 0 for _, v := range arr { sum += v } if n \u0026lt; 3 || sum%3 != 0 { return false } k := sum / 3 m := make(map[string]bool) return threeSubset(arr, k, k, k, m) } func threeSubset(arr []int, k1, k2, k3 int, m map[string]bool) bool { n := len(arr) if k1 == 0 \u0026amp;\u0026amp; k2 == 0 \u0026amp;\u0026amp; k3 == 0 { return true } if n == 0 { return false } s := strconv.Itoa(k1) + \u0026#34;+\u0026#34; + strconv.Itoa(k2) + \u0026#34;+\u0026#34; + strconv.Itoa(k3) + \u0026#34;+\u0026#34; + strconv.Itoa(n) if _,ok := m[s]; ok { return m[s] } a := false if k1 \u0026gt;= arr[0] { a = threeSubset(arr[1:], k1-arr[0], k2, k3, m) } if a == true { m[s] = true return a } b := false if k2 \u0026gt;= arr[0] { b = threeSubset(arr[1:], k1, k2-arr[0], k3, m) } if b == true { m[s] = true return b } c := false if k2 \u0026gt;= arr[0] { c = threeSubset(arr[1:], k1, k2, k3-arr[0], m) } m[s] = c return c } Great. Now let\u0026rsquo;s go though several test cases to see how the program works.\narr = {1, 1, 2, 2, 3, 3} \u0026ndash;\u0026gt; true\narr = {1, 1, 4} \u0026ndash;\u0026gt; false\narr = {1, 2, 3, 4, 5, 5, 7, 7, 8, 10, 12, 19, 25} \u0026ndash;\u0026gt; true\n","href":"/docs/threesubsetequalsum/","title":"Divide an array into 3 subsets with equal sum - Dynamic Programming"},{"content":"","href":"/tags/dp/","title":"DP"},{"content":"","href":"/tags/dynamic-programming/","title":"dynamic programming"},{"content":"","href":"/tags/example/","title":"example"},{"content":"","href":"/categories/features/","title":"features"},{"content":"","href":"/tags/go/","title":"go"},{"content":"","href":"/tags/golang/","title":"golang"},{"content":"","href":"/tags/recursive/","title":"recursive"},{"content":"","href":"/tags/","title":"Tags"},{"content":"","href":"/authors/tracey/","title":"tracey"},{"content":"Source code\nWe are going to solve this problem by using Dynamic Programming with memoisation and tabulation techniques.\nProblem Description The longest common subsequence (LCS) problem is to compute the length of a longest subsequence common to all given sequences. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous. For example, the LCS of two sequence {1,2,3} and {1,3,5} is {1,3}, and has the length is 2.\nThe problem in case of two sequences is described as follows.\nInput: given two array \\( arr_1 = [a_1, a_2, ... , a_n] \\) and \\( arr_2 = [b_1, b_2, ..., b_m] \\)\nConstraints: \\( 1 \\leq n, m \\leq 100 \\); \\( -10^9 Output: the length \\( p \\) of their longest common subsequence.\nThe naive solution for this problem is to generate all subsequences of both given sequences and find the longest one. This approach is exponential in time complexity. We can improve time complexity by using DP.\nAlgorithm Let\u0026rsquo;s call \\( LCS(i,j) \\) is the length of LCS of \\( arr_1 = [a_1, a_2, ... , a_i] \\) and \\( arr_2 = [b_1, b_2, ..., b_j] \\). To compute the length of LCS, let\u0026rsquo;s consider several cases:\n If any of the string is empty, then there is no common subsequence at all \\[ LCS(i,0) = LCS(0,j) = 0 \\] If the characters match, then we have one more common element of both sequence \\[ LCS(i,j) = 1 + LCS(i-1, j-1) \\] If the characters are mismatched \\( arr_1[i] \\neq arr_2[j] \\), then we will find longer LCS from \\( LCS(i-1,j) \\) and \\( LCS(i,j-1) \\) \\[ LCS(i,j) = max\\{LCS(i-1,j), LCS(i,j-1)\\} \\]  Implementation Tabulated DP The idea is to create a 2D array \\( arr[n+1][m+1] \\) to store the length of common subsequence in both sequences.\n If one of the string is empty then there is no common subsequence \\[ arr[i][j] = 0, \\] where \\( 0 \\leq i \\leq n, 0 \\leq j \\leq m \\) If the characters match \\( arr_1[i-1] = arr_2[j-1] \\) then \\[ arr[i][j] = 1 + arr[i-1][j-1] \\] If the characters are unmatched \\( arr_1[i-1] \\neq arr_2[j-1] \\) then \\[ arr[i][j] = max \\{ arr[i-1][j], arr[i][j-1]\\} \\]  For example, the 2D array created when finding LCS of 2 sequences {11,12,13} and {11,13,15} is as follows.\n      11 12 13      i, j 0 1 2 3    0 0 0 0 0   11 1 0 1 1 1   13 2 0 1 1 2   15 3 0 1 1 2     func LCSof2Table(arr1, arr2 []int32) int { n := len(arr1) m := len(arr2) var arr [101][101]int // constraint: n, m \u0026lt;= 100 // when i = 0 or j = 0 - means one of the given string is empty // i = 1: consider 1st element in the arr1 (index 0) = arr[0]  for i := 0; i \u0026lt;= n; i++ { for j := 0; j \u0026lt;= m; j++ { if i == 0 || j == 0 { arr[i][j] = 0 } else { if arr1[i-1] == arr2[j-1] { arr[i][j] = 1 + arr[i-1][j-1] } else { arr[i][j] = max(arr[i-1][j], arr[i][j-1]) } } } } return arr[n][m] } // utility function to get max of 2 integers func max(a,b int) int { if a \u0026gt; b { return a } return b } Let\u0026rsquo;s run the program\nfunc main() { arr1 := []int32{11, 12, 13} arr2 := []int32{11, 13, 15} fmt.Println(LCSof2Table(arr1, arr2)) } Output: 2\nTime complexity of this approach is \\( O(nm) \\)\nMemoisation DP The idea is to use a map mapOf2 to cache the overlapping operations in recursive calls. Base case is when one of two array is empty, or when n == 0 || m == 0. The return value in base case is 0\nfunc LCSof2Map(arr1, arr2 []int32) int { n := len(arr1) m := len(arr2) mapOf2 := make(map[[2]int]int) return LCSof2(arr1, arr2, n, m, mapOf2) } func LCSof2(arr1, arr2 []int32, n, m int, mapOf2 map[[2]int]int) int { if n == 0 || m == 0 { return 0 } if _, ok := mapOf2[[2]int{n, m}]; ok { return mapOf2[[2]int{n, m}] } if arr1[n-1] == arr2[m-1] { res := 1 + LCSof2(arr1, arr2, n-1, m-1, mapOf2) mapOf2[[2]int{n, m}] = res return res } res := max(LCSof2(arr1, arr2, n-1, m, mapOf2), LCSof2(arr1, arr2, n, m-1, mapOf2)) mapOf2[[2]int{n, m}] = res return res } } // utility function to get max of 2 integers func max(a,b int) int { if a \u0026gt; b { return a } return b } LCS of three sequences Now our problem is finding the LCS of three sequences \\( arr_1 = [a_1, a_2, ... , a_n] \\) , \\( arr_2 = [b_1, b_2, ..., b_m] \\), and \\( arr_3 = [c_1, c_2, ..., c_l] \\).\nThis problem is just an extension of the LCS problem of two sequences above.\nTabulation approach We are going to use a 3D array to store the calculated values.\nfunc LCSof3Table(arr1, arr2, arr3 []int32) int { n := len(arr1) m := len(arr2) var l = len(arr3) arr := make([][101][101]int, 101) for i := 0; i \u0026lt;= n; i++ { for j := 0; j \u0026lt;= m; j++ { for k := 0; k \u0026lt;= l; k++ { if i == 0 || j == 0 || k == 0 { arr[i][j][k] = 0 } else { if arr1[i-1] == arr2[j-1] \u0026amp;\u0026amp; arr1[i-1] == arr3[k-1] { arr[i][j][k] = 1 + arr[i-1][j-1][k-1] } else { arr[i][j][k] = max(arr[i-1][j][k], arr[i][j-1][k], arr[i][j][k-1]) } } } } } return arr[n][m][l] } // Utility function func max(a, b, c int) int { max := a if a \u0026lt; b { max = b } if max \u0026lt; c { return c } return max } Memoisation approach func LCSof3Map(arr1, arr2, arr3 []int32) int { n := len(arr1) m := len(arr2) l := len(arr3) mx := make(map[[3]int]int) return LCSof3(arr1, arr2, arr3, n, m, l, mx) } func LCSof3(arr1, arr2, arr3 []int32, n, m, l int, mx map[[3]int]int) int { if n == 0 || m == 0 || l == 0 { return 0 } if _, ok := mx[[3]int{n, m, l}]; ok { return mx[[3]int{n, m, l}] } if arr1[n-1] == arr2[m-1] \u0026amp;\u0026amp; arr1[n-1] == arr3[l-1] { res := 1 + LCSof3(arr1, arr2, arr3, n-1, m-1, l-1, mx) mx[[3]int{n, m, l}] = res return res } res := max(LCSof3(arr1, arr2, arr3, n-1, m, l, mx), LCSof3(arr1, arr2, arr3, n, m-1, l, mx), LCSof3(arr1, arr2, arr3, n, m, l-1, mx)) mx[[3]int{n, m, l}] = res return res } // Utility function func max(a, b, c int) int { max := a if a \u0026lt; b { max = b } if max \u0026lt; c { return c } return max } ","href":"/docs/lcs/","title":"Longest Common Subsequence (LCS) - Dynamic Programming"},{"content":"","href":"/tags/tabulation/","title":"tabulation"},{"content":"Source code\nProblem description An array is said to have a majority element if more than half of its elements are the same.\nGiven a non-empty array arr. Check to see if the array has a majority element.\nImplementation Let\u0026rsquo;s have a look at some approaches of solving the given problem.\n1- Brute Force algorithm This approach is to find the occurrences of each element. As soon as there is an occurrence of an element is greater than a half, we know that this array has majority element and then return true. Otherwise, return false\nfunc bruteForce(arr []int32) bool { n := len(arr) for _, v:= range arr { count := 0 for i := 0; i \u0026lt; n; i++ { if arr[i] == v { count += 1 } } if count \u0026gt; n/2 { return true } } return false } Time complextiy \\( O(n^2) \\).\nSpace complexity \\( O(1) \\).\n2- Sorting If the array is sorted, and if that array has majority element, that element should be located at index n/2 where n is the total number of elements in the array (length of the array). So all we need to do is checking whether all the elements are the same and equal to element at index n/2 in the sliding window\u0026rsquo;s size at least n/2+1. If yes, return true, otherwise, return false.\nfunc sortArray(arr []int32) bool { sort.Slice(arr, func(i, j int) bool { return arr[i] \u0026lt; arr[j] }) n := len(arr) for i := 0; i \u0026lt; n/2; i++ { if arr[i] == arr[n/2] { if arr[i+n/2] == arr[n/2] { return true } } } return false } As we can see, the time and space complexities of above approach are the time and space complexities of sorting algorithm that we used. For example, in case you sort the array by applying merge sort algorithm, the time complexity will be \\( O(n\\log n) \\), and space complexity will be \\( O(n) \\).\n3- Using Map You can reduce time complexity to \\( O(n) \\) while maintaining space complexity \\( O(n) \\) by using a map. I love this method, and it was the first one that came to my mind when I was given the problem.\nWe will create a map with keys are array elements, and its values are element\u0026rsquo;s occurrences. As soon as any value of a key is greater than n/2, the program returns.\nfunc useMap(arr []int32) bool { n := int32(len(arr)) m := make(map[int32]int32) for _,v := range arr { m[v] += 1 if m[v] \u0026gt; n/2 { return true } } return false } 4- Divide and conquer technique We repeatedly split the array into 2 sub-arrays and find the majority element of each array. After getting majority elements of both arrays, we do some comparisons. If the left and right majority are the same, it will be the majority of the whole array. Otherwise, we will see which element appears more than n/2 in the array by making call to getFrequency() function.\n// This func is used to return bool value. Disregard this func if you want to return majority element func DivideAndConquer(arr []int32) bool { majorityElement := ifMajority(arr) if majorityElement == -1 { return false } return true } func ifMajority(arr []int32) int32 { n := int32(len(arr)) if n == 1 { return arr[0] } leftArray := arr[:n/2] rightArray := arr[n/2 :] elemLeft := ifMajority(leftArray) elemRight := ifMajority(rightArray) // -1 value is referred to no-majority element in considered array. \t// Check -1 condition to reduce some calls to `getFrequency()` when return element is -1 \tif elemLeft == -1 \u0026amp;\u0026amp; elemRight == -1 { return -1 } if elemRight == -1 || elemLeft == elemRight { return elemLeft } if elemLeft == -1 { return elemRight } freqLeft := getFrequency(arr, elemLeft) freqRight := getFrequency(arr, elemRight) if freqLeft \u0026gt; n/2 { return freqLeft } else if freqRight \u0026gt; n/2 { return freqRight } else { return -1 } } // To get frequency of value k appears in arr func getFrequency(arr []int32, k int32) int32 { count := int32(0) for _,v := range arr { if k == v { count += 1 } } return count } Time complexity \\( O(n \\log n) \\).\nSpace complexity \\( O(\\log n) \\).\n5- Boyer-Moore voting algorithm The idea of this method is that, if the array has majority element, so that element should be repeating more than n/2 times. Hence, if at every occurrences of majority element we count 1, and the other elements we count -1, the total count should be greater than 0.\nIn implementation of the method, we are going to have 2 loops. The first loop is to obtain the majority element if there is such majority. The second loop is to check is the obtained number actually majority by checking its frequency. More details can be found at that link.\nfunc BoyerMoore(arr []int32) bool { count := 0 currentNumber := int32(0) for _,v := range arr { if count == 0 { currentNumber = v count = 1 } if v == currentNumber { count += 1 } else { count -= 1 } } count = 0 for _, v := range arr { if v == currentNumber { count += 1 } } if count \u0026gt; len(arr)/2 { return true } return false } Time complexity \\( O(n) \\).\nSpace complexity \\( O(1) \\).\n","href":"/docs/majorityelement/","title":"Majority Element Of An Array"},{"content":"","href":"/tags/map/","title":"map"},{"content":"Source code\nA linear search is a searching algorithm that find the position of an element from a list by sequentially comparing the elements of the list until finding the matching element. This is the simplest searching algorithm and is practical when the list has only a few elements or when performing a single search in an unsorted array. Linear search has worst-case and average-case time complexity \\( O(n) \\), and best case time complexity \\( O(1) \\). Its space complexity is \\( O(1) \\).\nWhen the given array is sorted, binary search is more efficient algorithm. Binary search is based on the principle of divide and conquer by repeatedly dividing in half the portion of the list that could contain the item, until the possible locations is narrowed just to one.\nFirst, it compares the target value with the middle element of the array. If a match occurs, then the index of middle element is returned. If the middle item is greater than target value, then the search continues on the left sub-array. Otherwise, the item is searched on the right sub-array. Again, taking the middle element to compare to the target value, and process is repeated until the target value is found.\nImplementation\nfunc binarySearch(arr []int64, k int64) int64 { return index(arr, k, int64(len(arr))-1, 0) } // arr - given sorted array // k - target value // h - the highest value // l - the lowest value. h and l are used to define the sub-array func index(arr []int64, k, h, l int64) int64 { if h \u0026lt; l { return -1 } mid := l + (h-l)/2 if k == arr[mid] { return mid } if k \u0026gt; arr[mid] { return index(arr, k, h, mid+1) } return index(arr, k, mid-1, l) } Binary search has worst-case and average case time complexity \\( O(\\log n) \\), and best case time complexity \\( O(1) \\). The best case occurs when the searching key is in the middle of the array. Its space complexity is \\( O(1) \\).\n","href":"/docs/binarysearch/","title":"Binary Search"},{"content":"","href":"/tags/binary-search/","title":"binary search"},{"content":"Source code\nDynamic programming solves the complex problem by breaking it into simpler sub-problems, solving each of those once, and storing their solution for later use. Dynamic programming uses memoisation and tabulation technique for improving its performance.\nMemoisation is a technique of optimisation by storing the solutions of function calls and returning the cached result when the same inputs are called again.\nTabulation is an approach by first filling up a table, then solving the original problem based on the solutions in this table.\n I will illustrate the memoisation technique in this example. Memoisation improves the performance of recursion by reusing the cached solution.\nFirst let\u0026rsquo;s have a quick look at Fibonacci number problem solving by recursive approach.\nfunc Fibonacci(n int) int64 { if n \u0026lt;= 1 { return 1 } return Fibonacci(n-1) + Fibonacci(n-2) } The time complexity of this approach is nearly \\( O(n^2) \\) and space complexity is \\( O(n) \\).\nWe can observed that the implementation does a lot of repeated computation as shown in the following diagram.\nBy using dynamic programming with memoisation we can reduce the time complexity to \\( O(n) \\) by just storing the computed Fibonacci numbers in a map (source code). However, we need to store computed value in a map, so space complexity for this algorithm is still \\( O(n) \\).\nfunc FibonacciNumber(n int) int64 { m := make(map[int]int64) return FibonacciDP(n,m) } func FibonacciDP(n int, m map[int]int64) int64 { if n \u0026lt;= 1 { return int64(n) } if _,ok := m[n]; ok { return m[n] } fn := FibonacciDP(n-1,m) + FibonacciDP(n-2,m) m[n] = fn return fn } The most optimal technique for calculating Fibonacci number is using Bottom-up algorithm, where we only need to store the previous two numbers only as shown in my other post. The time complexity in that case is \\( O(n) \\) while space complexity is \\( O(1) \\).\n Now we are going to have a look at another example: coin change problem. We are given a list of coins with different values c = [c1,c2,c3, ...] and a total amount of money n. Our task is determine the number of different ways of making change for that amount of money, if each coin is available in infinite quantities. For example, if you are given a list of coins [1,2,3], and the total amount is 3, you can make 3 ways of change: {1,1,1}, {1,2}, and {3}.\nWe can see that, the total way of making change to amount n is equal to the way of change by using 0, 1, 2, ... coin value c1 to amount n, n-c1, n-2c1, ....\nIn general\nways(n, c[c1,c2,c3,...]) = ways(n, c[c2,c3,...]) + ways(n-c1, c[c2,c3,...]) + ways(n-2*c1, c[c2,c3,...]) + ...\rEach call ways() once again by itself can divide into smaller subproblems, and so on. The implementation is as follows.\nfunc ways(n int64, c []int64) int64 { m := make(map[[2]int64]int64) return helper(c, int64(n), m) } func helper(arr []int64, n int64, m map[[2]int64]int64) int64 { if n == 0 { return 1 } k := int64(len(arr)) if k == 0 { return 0 } if n \u0026lt; 0 { return 0 } if _, ok := m[[2]int64{k, n}]; ok { return m[[2]int64{k, n}] } count := int64(0) i := int64(0) for n-i*arr[0] \u0026gt;= 0 { count += helper(arr[1:], n-i*arr[0], m) i++ } m[[2]int64{k, n}] = count return count } It is noted that the key type in the map above is an array of 2 elements, not a slice.\n","href":"/docs/dynamicprogramming/","title":"Coin Change Problem - Dynamic Programming"},{"content":"Source code\nGolang supports recursion, that allows function to call itself. A recursive function has a base case which is the final executable statement in recursion. The base case is needed to be defined carefully, otherwise the program will go on to infinite loop.\nLet\u0026rsquo;s consider the following example that applied recursive function directly.\nOur program is to find super digit on an given integer x, which is defined as follows.\n Equal x if x is single-digit number Equal to the super digit of the sum of the digits of x  For example, the super digit of 123 is calculated as\nsuper_digit(128) = super_digit(1+2+8) = super_digit(11) = super_digit(1+1) = super_digit(2) = 2 Our program looks like as follows.\nfunc superDigit(n string) int { sum := int64(0) for _, v := range n { a, _ := strconv.ParseInt(string(v), 10, 64) sum += a } if sum \u0026lt; 10 { return int(sum) } stringSum := strconv.FormatInt(sum, 10) return superDigit(stringSum) } It at first calculates the sum of the digits of x and assigns this number to variable sum. It then check whether sum is single-digit number. If yes, return sum as we have found the super digit. Otherwise, it calls itself (function superDigit()) again to calculate the sum of the digits of sum until it reaches the base case of single-digit number\nLet\u0026rsquo;s try to find super digit of number 128\nfunc main() { fmt.Println(superDigit(\u0026#34;128\u0026#34;)) } Print out: 2\nLet\u0026rsquo;s go step by step though execution\ncall superDigit(\u0026quot;123\u0026quot;) --\u0026gt; calculate sum: 11\r--\u0026gt; check condition sum \u0026lt; 10: false\r--\u0026gt; stringSum: \u0026quot;11\u0026quot;\r--\u0026gt; call superDigit(\u0026quot;11\u0026quot;)\r--\u0026gt; calculate sum: 2\r--\u0026gt; check condition sum \u0026lt; 10: true\r--\u0026gt; return 2\r--\u0026gt; return 2\r","href":"/docs/superdigitrecursion/","title":"Recursion in Go"},{"content":"Source code\nGo map Go map is built-in type that implements a hash table - a very useful data structure in computer science. A Go map type is defined as\nmap[Key]Value We use make function to initialise a map, and also need to define types for map\u0026rsquo;s Key and Value. For example, initialisation of a map of string keys to float64 values is as follows.\nm := make(map[string]float64) Let have a quick look at an small example about inserting, looking up, and deteting data from a map.\nm := make(map[string]float64) // Map literal m[\u0026#34;pi\u0026#34;] = 3.14 m[\u0026#34;e\u0026#34;] = 2.72 fmt.Println(m) //Print out `m(e: 2.72 pi: 3.14)`  // Print value of key \u0026#34;pi\u0026#34; fmt.Println(m[\u0026#34;pi\u0026#34;]) // Print out 3.14  // Checking whether map m contains a key. Return value is `bool` _, ok := m[\u0026#34;pi\u0026#34;] fmt.Println(ok) //Print out `true` _, ok = m[\u0026#34;pie\u0026#34;] fmt.Println(ok) //Print out `false`  // Deleting a key-value pair delete(m, \u0026#34;pi\u0026#34;) fmt.Println(m) //Print out `m(e: 2.72)`  In general, map performance is \\( O(1) \\) for inserting, looking up, and deleting data even though there is not any performance guarantees for map.\nExample description We are given an array of unique integers arr and a target value k. We are going to find how many pairs of array elements that have a difference equal to the target value.\nThe idea for solving that problem is using Go map. We first create a map with its key is array element, and its value is the appearance of that element in the array. In this example, values are always equal 1 as the given integers are unique. Then, we go through the map, check whether another element of a pair exists in the map. If yes, we increase out count to 1.\nfunc pairs(k int32, arr []int32) int32 { m := make(map[int32]int32) for _, v := range arr { m[v] += 1 } pairs := int32(0) for _, v := range arr { if _, ok := m[v+k]; ok { pairs += 1 } } return pairs } Let\u0026rsquo;s run our program\nfunc main() { arr := []int32{1, 5, 3, 4, 2} fmt.Println(pairs(2, arr)) } Print out: 3\n","href":"/docs/mapexample/","title":"Find Pairs With the Same Difference from an Array- Map Example"},{"content":"Source code\nWe are given an array of positive integers, and our task is arranging them in a way that yields largest value.\nIn case the given array consists of all single-digit numbers, we can achieve the largest value easily just by composing the number from a descending sorted array. All what we need to do is sorting the given array in descending order by applying any sorting algorithms.\nBut how about in the case that given array consists of arbitrary positive integers? In that case, using the largest number from the given array for the first number does not work. For example, with the set [12 9 3], the largest composed number is 9312 instead of 1293.\nActually, we still just need to use merge sort algorithm, but with a small modification. In this modified merge sort, instead of comparing value of 2 integers x and y, we will compare the value of their combination, i.e ab and ba. If ab \u0026gt; ba, then integer a is considered greater than b, and vice versa. After sorting, all we need to do is composing the largest number.\nImplementation\nImplement modified merge sort\nfunc mergedSort(arr []int) []int { if len(arr) \u0026lt; 2 { return arr } mid := len(arr) / 2 left := arr[:mid] right := arr[mid:] return merge(mergedSort(left), mergedSort(right)) } func merge(left, right []int) []int { res := make([]int,0, len(left)+len(right)) for len(left) \u0026gt; 0 || len(right) \u0026gt; 0 { if len(left) == 0 { return append(res, right...) } if len(right) == 0 { return append(res, left...) } xy,_ := strconv.Atoi(strconv.Itoa(left[0])+strconv.Itoa(right[0])) yx,_ := strconv.Atoi(strconv.Itoa(right[0])+strconv.Itoa(left[0])) if xy \u0026gt; yx { res = append(res, left[0]) left = left[1:] } else { res = append(res, right[0]) right = right[1:] } } return res } Compose largest number\nfunc largestNumber(arr []int) string { arr = mergedSort(arr) var s string for _, v := range arr { s = s + strconv.Itoa(v) } return s } Let\u0026rsquo;s test our program\nfunc main() { arr := []int{4, 6, 9, 23, 95} fmt.Println(largestNumber(arr)) } Print out: 9956423\n","href":"/docs/modifiedmergesort/","title":"Compose the largest number out of given set of integers"},{"content":"","href":"/tags/merge-sort/","title":"merge sort"},{"content":"","href":"/tags/sort/","title":"sort"},{"content":"Source code\nWe are going to have a look at several sorting algorithms, their implementation, and their performance. In particular, we will discuss about Bubble Sort, Insertion Sort, and Merge Sort.\n1- Bubble Sort Bubble Sort is a sorting algorithm that repeatedly swap the adjacent elements if they are in wrong order. It repeatedly pass through the list until the list is sorted.\n\u0026ldquo;File:Bubble-sort-example-300px.gif\u0026rdquo; by Swfung8 is licensed under CC BY-SA 3.0 func bubbleSort(arr []int32) []int32 { n := len(arr) sorted := false for !sorted { sorted = true for i := 0; i \u0026lt; n-1; i++ { if arr[i] \u0026gt; arr[i+1] { arr[i], arr[i+1] = arr[i+1], arr[i] sorted = false } } } return arr } Bubble sort has worst-case and average case time complexity \\( O(n^2) \\), and best case time complexity \\( O(n) \\). The best case occurs when array is already sorted, and the worst case is when array is sorted in reverse order. Its space complexity is \\( O(1) \\) due to sorting in place.\n2- Insertion Sort Insertion sort iterates up the array, grows the sorted list behind it. At each iteration, it goes though the sorted list, compares the value against each value in the list to find the right position, and insert the element into that correct position.\n\u0026ldquo;File:Insertion-sort-example-300px.gif\u0026rdquo; by Swfung8 is licensed under CC BY-SA 3.0 func insertionSort(arr []int32) []int32 { n := len(arr) for i := 1; i \u0026lt; n; i++ { j := i swapped := false for !swapped \u0026amp;\u0026amp; j \u0026gt;= 1 { swapped = true if arr[j] \u0026lt; arr[j-1] { arr[j], arr[j-1] = arr[j-1], arr[j] j-- swapped = false } } } return arr } Similar to bubble sort, insertion sort has worst-case and average case time complexity \\( O(n^2) \\), and best case time complexity \\( O(n) \\), space complexity \\( O(1) \\).\n3- Selection Sort Selection sort iterates through the array to find the minimum number, and swap it with the beginning element in the array. It hence divides the given array into 2 sub-arrays - sorted at the left, and unsorted at the right. In other word, in every iteration, the minimum element from the unsorted sub-array is found and moved to the end of the sorted sub-array. The unsorted sub-array hence narrows by one element.\n\u0026ldquo;By Joestape89, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=3330231 func selectionSort(arr []int) []int { for i := 0; i \u0026lt; len(arr); i++ { minIndex := findIndexMin(arr, i) arr[i], arr[minIndex] = arr[minIndex], arr[i] } return arr } func findIndexMin(arr []int, start int) int { i := start min := arr[start] j := start for j \u0026lt; len(arr)-1 { j++ if min \u0026gt; arr[j] { min = arr[j] i = j } } return i } Time complexity \\( O(n^2) \\).\nSpace complexity \\( O(1) \\).\n4- Merge Sort Merge Sort works as follows:\n Break the array into multiple sub-arrays with single element. Or in other words, break down the problem into base problems. Merge all these sorted sub-arrays to form one single sorted array.  \u0026ldquo;File:Merge-sort-example-300px.gif\u0026rdquo; by Swfung8 is licensed under CC BY-SA 3.0 func mergeSort(arr []int) []int { if len(arr) \u0026lt; 2 { return arr } mid := len(arr) / 2 left := arr[:mid] right := arr[mid:] return merge(mergeSort(left), mergeSort(right)) } func merge(left, right []int) []int { res := make([]int,0, len(left)+len(right)) for len(left) \u0026gt; 0 || len(right) \u0026gt; 0 { if len(left) == 0 { return append(res, right...) } if len(right) == 0 { return append(res, left...) } if left[0] \u0026lt; right[0] { res = append(res, left[0]) left = left[1:] } else { res = append(res, right[0]) right = right[1:] } } return res } Merge sort has time complexity \\( O(n \\times \\log n) \\) in all the cases, and space complexity \\( O(n) \\).\n5- QuickSort - 2 ways partition QuickSort is a Divide and Conquer algorithm. It picks a random element as pivot, and rearranges the ordinary array based on that pivot number. The procedure of rearrange the elements in array as above is call partitioning. In 2 way partition QuickSort, the array is divided into 2 sub-arrays: the left one with all numbers less than pivot number, and the right one with all number greater than pivot number.After partitioning the pivot is in its final position. Recursively the above process for the left and right sub-arrays\n\u0026ldquo;File:Quicksort-example.gif\u0026rdquo; by Matt Chan (jacky\u0026rsquo;s brother) is licensed under CC BY-SA 3.0, via Wikimedia Commons func quicksort2way(arr []int) []int { sort2way(arr, 0, len(arr)-1) return arr } func sort2way(arr []int, left, right int){ pivot := arr[(right+left)/2] i := left j := right for i \u0026lt; j { for arr[i] \u0026lt; pivot \u0026amp;\u0026amp; i \u0026lt;= j { i++ } for arr[j] \u0026gt; pivot \u0026amp;\u0026amp; i \u0026lt;= j { j-- } arr[i], arr[j] = arr[j], arr[i] i++ j-- } if left \u0026lt; i - 1 { sort2way(arr, left, i - 1) } if right \u0026gt; i { sort2way(arr, i, right) } } 6- Improved QuickSort - 3 ways partition This algorithms splits the array into three sub-arrays based on a pivot number:\n arr[left .. i-1] - elements less than pivot number arr[i .. j] - elements equal to pivot number arr[j+1 .. right] - elements greater than pivot number  After a partition, the elements equal to pivot number are already in their correct position, and we only need to rearrange left and right sub-arrays.\nTo do so, our quickSort() function will call function sortArr() and pass in 3 input variables - the original array, left and right indices that indicate start and end of a sub-array. We are going to sort the indicated sub-array only.\nfunc quickSort(arr []int32) []int32 { sortArr(arr, 0, int32(len(arr))-1) return arr } func sortArr(arr []int32, left, right int32) { //n := int32(len(arr)) \tstart := left stop := right if stop-start \u0026lt; 1 { return } splitIndex := start //pivot := rand.Int31n(n) \tpivot := arr[start+(stop-start)/2] for splitIndex \u0026lt;= stop { if arr[splitIndex] \u0026lt; pivot { arr[start], arr[splitIndex] = arr[splitIndex], arr[start] splitIndex++ start++ } else if arr[splitIndex] \u0026gt; pivot { arr[stop], arr[splitIndex] = arr[splitIndex], arr[stop] stop-- } else { splitIndex++ } } i, j := start-1, stop+1 sortArr(arr, left, i) sortArr(arr, j, right) } A pivot number is a random number. In my implementation, it is chosen to be the number at the middle of the array. splitIndex is the index where the array splits into sub-arrays. At first, the splitIndex is given to be equal to the start variable. We then compare the value at splitIndex with pivot. After comparison, the value is moved to left sub-array if less than pivot, or to right sub-array if greater than pivot. After getting 3 sub-arrays, we recursively sort the left and right sub-arrays until the original array is sorted.\nThe 3 way partition algorithm is an improved quicksort algorithm as it handles input with many replicated elements.\nQuicksort has time complexity \\( O(n \\times \\log n) \\), and space complexity \\( O(1) \\).\nYou can have a visual look at different sorting algorithms by visit the following link: Toptal Sorting Algorithms Animation\n","href":"/docs/sortingalgorithms/","title":"Sorting Algorithms"},{"content":"","href":"/tags/fibonacci/","title":"Fibonacci"},{"content":"","href":"/tags/gcd/","title":"GCD"},{"content":"","href":"/tags/lcm/","title":"LCM"},{"content":"Source code\nThis post is about some problems that can be solved easily only by using math formula.\n1- Greatest common divisor and Least Common Multiple The greatest common divisor \\( GCD(a,b) \\) of two non-negative integers \\( a \\) and \\( b \\) (which are not both equal to 0) is the greatest integer that divides both \\( a \\) and \\( b \\).\nThe least common multiple of two positive integers \\( a \\) and \\( b \\) is the least positive integer that is divisible by both \\( a \\) and \\( b \\).\nYou can compute \\( GCD(a,b) \\) by implementing Euclidean algorithm, which is defind as follows \\[ GCD(a,0) = a \\] \\[ GCD(a,b) = GCD(b,r) \\] where \\( a = b\\times q + r \\)\nOn the other hand, there is a close relation between \\( GCD(a,b) \\) and \\( LCM(a,b) \\) \\[ LCM(a,b) = {a\\times b \\over GCD(a,b)} \\]\nImplementation Greatest common divisor\nfunc GCD(a,b int64) int64 { r := int64(1) for r !=0 { r = a%b if r == 0 { return b } a,b = b,r } return a/b } Least common multiple\nfunc LCM(a,b int64) int64 { return a*b/GCD(a,b) } 2- Fibonacci number and related problems Fibonacci numbers are defined as: \\( F_0 = 0, F_1 = 1 \\), and \\( F_i = F_{i-1} + F_{i-2} \\) for \\( \\forall i \\ge 2 \\).\nfunc fibonacci(n int) int64 { if n \u0026lt;= 1 { return n } a := int64(0) b := int64(1) var fi int64 for i := 2; i \u0026lt;= n; i++ { fi = a + b a,b = b, fi } return fi } As Fibonacci number grows very fast and soon overload with type int64. For convenience, we only computes the last digit of each problems so on. Hence, the above fibonacci() is modified as follows.\nfunc lastDigitFibonacci(n int) int { if n == 0 { return 0 } if n == 1 { return 1 } a := 0 b := 1 var fi int for i := 2; i \u0026lt;= n; i++ { fi = (a + b)%10 a,b = b, fi } return fi } Now let\u0026rsquo;s have a look at some other Fibonacci problems.\nSum of the first n Fibonacci numbers \\( F_0 + F_1 + ... + F_n\\)\n\\[ \\sum_{i=0}^{i=n} {F_i} = F_{n+2}-1\\] func lastDigitSum(n int) int { return lastDigitFibonacci(n+2)-1 } Partial sum of Fibonacci numbers \\( F_m + F_{m+1} + ... + F_n\\) \\[ \\sum_{i=m}^{i=n} {F_i} = F_{n+2}-F_{m+1} \\]\nfunc lastDigitPartialSum(m,n int64) int { a := lastDigitFibonacci(n+2) b := lastDigitFibonacci(m+1) if a \u0026gt; b { return a-b } return a+10-b } Sum of square of Fibonacci numbers \\( F_0^2 + F_1^2 + ... + F_n^2\\)\n\\[ \\sum_{i=0}^{i=n} {F_i^2} = F_{n} \\times F_{n+1}\\] func lastDigitSquareSumFib(n int64) int { if n \u0026lt; 2 { return int(n) } a := 0 b := 1 for i := int64(2); i \u0026lt;= n+1; i++ { a, b = b,(a + b)%10 } return (a*b)%10 } Will come back later when I find some more such problems ðŸ˜Ž\n","href":"/docs/mathprob/","title":"Nothing more than Math"},{"content":"Source code\nThis is an example of struct, method, and interface.\nI define an interface named geometry that has area() and perim() method signatures.\ntype geometry interface { area() float64 perim() float64 } I also define 3 other types circle, rectangle and triangle that implement geometry interface. For example, type circle implements all the geometry interface methods as follows.\ntype circle struct { radius float64 } func (c circle) area() float64 { return math.Pi * c.radius * c.radius } func (c circle) perim() float64 { return math.Pi * 2 * c.radius } My program allows user query for area and perimeter of a particular shape. Note that the shape is restricted to either circle, rectangle, or triangle. In order to make a query, the user has to type in the shape name. Then, new prompts are printed out to ask for shape dimensions, and then for requested method. The program after processing the data will print out either area or perimeter of the requested shape. My program will continue in this loop forever unless it is stopped by user.\nfunc main() { scanner := bufio.NewScanner(os.Stdin) var g geometry fmt.Printf(\u0026#34;\u0026gt; \u0026#34;) for scanner.Scan() { data := scanner.Text() switch data { case \u0026#34;circle\u0026#34;, \u0026#34;Circle\u0026#34;: fmt.Printf(\u0026#34;Radius = \u0026#34;) scanner.Scan() d := scanner.Text() r, _ := strconv.ParseFloat(d, 64) g = circle{r} case \u0026#34;rectangle\u0026#34;, \u0026#34;Rectangle\u0026#34;: fmt.Printf(\u0026#34;length and width = \u0026#34;) scanner.Scan() d := scanner.Text() slice := strings.Split(d, \u0026#34; \u0026#34;) l, _ := strconv.ParseFloat(slice[0], 64) w, _ := strconv.ParseFloat(slice[1], 64) g = rectangle{l, w} case \u0026#34;triangle\u0026#34;, \u0026#34;Triangle\u0026#34;: fmt.Printf(\u0026#34;sides = \u0026#34;) scanner.Scan() d := scanner.Text() slice := strings.Split(d, \u0026#34; \u0026#34;) a, _ := strconv.ParseFloat(slice[0], 64) b, _ := strconv.ParseFloat(slice[1], 64) c, _ := strconv.ParseFloat(slice[2], 64) g = triangle{a, b, c} } fmt.Printf(\u0026#34;requested method: \u0026#34;) scanner.Scan() s := scanner.Text() measure(g,s) fmt.Printf(\u0026#34;\u0026gt; \u0026#34;) } } A helper function measure() is used to process the data and print out the relevant information. It is a good example of using type switches, in which the cases specify not values but types.\nfunc measure(g geometry, s string) { switch shape := g.(type) { case circle: switch s { case \u0026#34;area\u0026#34;: fmt.Printf(\u0026#34;%0.3f\\n\u0026#34;,shape.area()) case \u0026#34;perimeter\u0026#34;: fmt.Printf(\u0026#34;%0.3f\\n\u0026#34;,shape.perim()) } case rectangle: switch s { case \u0026#34;area\u0026#34;: fmt.Printf(\u0026#34;%0.3f\\n\u0026#34;,shape.area()) case \u0026#34;perimeter\u0026#34;: fmt.Printf(\u0026#34;%0.3f\\n\u0026#34;,shape.perim()) } case triangle: switch s { case \u0026#34;area\u0026#34;: fmt.Printf(\u0026#34;%0.3f\\n\u0026#34;,shape.area()) case \u0026#34;perimeter\u0026#34;: fmt.Printf(\u0026#34;%0.3f\\n\u0026#34;,shape.perim()) } } } ","href":"/docs/interfaceexample/","title":"Area and Perimeter of a Geometry - Interface Example"},{"content":"","href":"/tags/interface/","title":"interface"},{"content":"","href":"/tags/method/","title":"method"},{"content":"","href":"/tags/avl-tree/","title":"AVL Tree"},{"content":"Source code\nIntroduction AVL tree is a height-balanced binary search tree (BST). In an AVL tree, every node maintains a balance factor, which is defined as follows\nbalance_factor := height(left_subtree) - height(right_subtree)\rAccording to definition of a balanced tree, the balance factor of every node in the AVL tree is either -1, 0, or 1. When an insertion or deletion operation is performed, the tree\u0026rsquo;s height may change, so do the balance factors at nodes. Whenever the balance factor of a node goes over the range, the tree will re-balance itself by operating rotation at that node. One can find more details here.\nRotation Basically, there is 4 cases that the tree is imbalanced at a node, and correspondingly 4 rotation methods that will be performed to make the tree balanced. It is noted that the below images of illustration rotation operations and insertion example are borrowed from BTeach Smart Class\n  The right subtree is too high, and the right child has a right child. In this case, Left Rotation operation is used to rotate the nodes one position to the left.   The left subtree is too high, and the left child has a left child. Right Rotation is used in this case to rotate nodes one position to the right.   The right subtree is too high, and the right child has a left child. This case requires double rotation operations called Right Left Rotation. At first, Right Rotation will be performed at the right node of given node, then a Left Rotation will be used at the given node.   The left subtree is too high, and the left child has a right child. Right Left Rotation operation will be used in this case.   Insertion Operation in AVL Tree A new element is inserted to an AVL tree in the same logic as to a BST. However, balance factor of each node is updated and checked after insertion. The tree is said to be imbalanced if the balance factor of any node is other than 0, 1 or -1. In that case, suitable rotation operation is used to re-balance the tree.\nIt can be shown that a height-balanced tree with n nodes has height \\( O(\\log n) \\). Since the cost of our algorithms is proportional to the height of the tree, each operation (lookup, insertion or deletion) will take time \\( O(\\log n) \\) in the worst case.\nExample - Construct an AVL tree by inserting numbers from 1 to 8\nImplementation We define a type Node with following fields: value, its left and right nodes, and its balance value.\ntype Node struct { Value int // value of a node \tLeft *Node // left node \tRight *Node // right node \tBal int // Bal = h_left - h_right } Insert() first inserts a given data to an existing AVL subtree at node n, then rebalances the subtree if needed by calling helper function Rebalance().\nfunc (n *Node) Insert(data int) { // Node already exists, do no change \tif data == n.Value { fmt.Println(\u0026#34;Node already exists\u0026#34;) return } // If data is less than value of Node c, traverse to the left. \t// Otherwise, traverse to the right \tif data \u0026lt; n.Value { // Left node does not exist. Create a new one \tif n.Left == nil { n.Left = \u0026amp;Node{Value: data} // Update Balance Factor of Node n \tn.Bal++ return } a := n.Left.Bal n.Left.Insert(data) // Check whether the tree\u0026#39;s height has changed after inserting \tif n.Left.Bal != 0 \u0026amp;\u0026amp; n.Left.Bal != a { if n.Left.Bal \u0026lt; -1 || n.Left.Bal \u0026gt; 1 { n.Rebalance(n.Left) } else { n.Bal++ } } return } if n.Right == nil { n.Right = \u0026amp;Node{Value: data} n.Bal-- return } b := n.Right.Bal n.Right.Insert(data) if n.Right.Bal != 0 \u0026amp;\u0026amp; n.Right.Bal != b { if n.Right.Bal \u0026lt; -1 || n.Right.Bal \u0026gt; 1 { n.Rebalance(n.Right) } else { n.Bal-- } } return } Rebalance() performs suitable rotation operation to make a subtree balanced by calling either LLRotation(), RRRotation(), LRRotation(), or RLRotation()\nfunc (n *Node) Rebalance(c *Node) { fmt.Printf(\u0026#34;Re-Balance @ node %v \\n\u0026#34;, c.Value) // Left subtree is too high, and left child has a left child. \tif c.Bal == 2 \u0026amp;\u0026amp; c.Left.Bal == 1 { n.RRRotation(c) return } // Right subtree is too high, and right child has a right child. \tif c.Bal == -2 \u0026amp;\u0026amp; c.Right.Bal == -1 { n.LLRotation(c) return } // Left subtree is too high, and left child has a right child. \tif c.Bal == 2 \u0026amp;\u0026amp; c.Left.Bal == -1 { n.LRRotation(c) return } // Right subtree is too high, and right child has a left child. \tif c.Bal == -2 \u0026amp;\u0026amp; c.Right.Bal == 1 { n.RLRotation(c) return } } func (n *Node) LLRotation(c *Node) { r := c.Right // create a temporary node r to hold node c.Right \tc.Right = r.Left // make left children of r become right children of c \tr.Left = c // make c as r left child \t// Update balance factor of node c and r \tif c.Left != nil \u0026amp;\u0026amp; c.Right == nil { c.Bal = 1 } else { c.Bal = 0 } r.Bal = 0 // Let parent node n point to new node r \tif c == n.Left { n.Left = r } else { n.Right = r } } func (n *Node) RRRotation(c *Node) { l := c.Left c.Left = l.Right l.Right = c if c.Right != nil \u0026amp;\u0026amp; c.Left == nil { c.Bal = -1 } else { c.Bal = 0 } l.Bal = 0 if c == n.Left { n.Left = l } else { n.Right = l } } func (n *Node) LRRotation(c *Node) { c.LLRotation(c.Left) n.RRRotation(c) } func (n *Node) RLRotation(c *Node) { c.RRRotation(c.Right) n.LLRotation(c) } A tree can either be empty or has a node. Each node in a tree has left and right subtrees. If a tree is empty, inserting an element to the tree is creating a root node.\nPerforming insertion to a tree has to take care of re-balancing the root node if the tree is imbalanced at root node. The root node has no parent, to be unable to use node\u0026rsquo;s rebalance method above a fake parent node is created. This node stores value -1, and root node is its either left child or right child.\ntype AVLTree struct { Root *Node } // Insertion func (t *AVLTree) Insert(data int) { if t.Root == nil { t.Root = \u0026amp;Node{Value: data} return } t.Root.Insert(data) // Check whether the root node gets out of balance \tif t.Root.Bal \u0026lt; -1 || t.Root.Bal \u0026gt; 1 { t.rebalance() } } func (t *AVLTree) rebalance() { rootParent := \u0026amp;Node{Left: t.Root, Value: -1} rootParent.Rebalance(t.Root) t.Root = rootParent.Left } print() will print the tree with displaying nodes\u0026rsquo; heights\nfunc (t *AVLTree) print(n *Node, height int) { if n == nil { return } format := \u0026#34;--[\u0026#34; t.print(n.Right, height+1) fmt.Printf(\u0026#34;%*s%d(%v)\\n\u0026#34;, 7*(height+1), format, n.Value, n.Bal) t.print(n.Left, height+1) } Now let\u0026rsquo;s go through an example of constructing an AVL Tree by inserting numbers from 1 to 6\nfunc main() { values := []int{1, 2, 3, 4, 5, 6} t := \u0026amp;AVLTree{} for i := 0; i \u0026lt; len(values); i++ { fmt.Printf(\u0026#34;Insert %v--------------------------\\n\u0026#34;, values[i]) t.Insert(values[i]) t.print(t.Root, 0) fmt.Println() } } Here\u0026rsquo;s the result: References  AVL Tree from BTech Smart Class Balanced BST from cs.ecu.edu Trees from sc.ecu.edu  ","href":"/docs/balancedbst/","title":"Balanced Binary Search Tree - AVL Tree"},{"content":"","href":"/tags/balanced-bst/","title":"Balanced BST"},{"content":"","href":"/tags/bst/","title":"BST"},{"content":"Source code\nFetch maximum value Maximum value of a BST is the value of the most right node\nfunc FetchMax(t *treeNode) int { if t.Right == nil { return t.Value } return FetchMax(t.Right) } Return value: 14\nFetch minimum value Minimum value of a BST is the value of the most left node\nfunc FetchMin(t *treeNode) int { if t.Left == nil { return t.Value } return FetchMin(t.Left) } Return: 1\nGet Height Helper functions: GetHeightLeaves and max\nfunc (t *treeNode) GetHeight(leaves []int) int { return max(leaves) } func (t *treeNode) GetHeightLeaves(height int, leaves *[]int) []int { if t.Left == nil \u0026amp;\u0026amp; t.Right == nil { *leaves = append(*leaves, height) } else { height++ if t.Left != nil { t.Left.GetHeightLeaves(height, leaves) } if t.Right != nil { t.Right.GetHeightLeaves(height, leaves) } } return *leaves } func max(arr []int) int { max := arr[0] for _, v := range arr { if max \u0026lt; v { max = v } } return max } One can also store an information about height in type node. In that case, height of a node is the maximum height between left subtree and right subtree plus one.\nheight = 1 + max(height_left, height_right) Print a tree func (t *treeNode) print(height int) { if t == nil { return } format := \u0026#34;--[\u0026#34; t.Right.print(height + 1) fmt.Printf(\u0026#34;%*s%d\\n\u0026#34;, 7*(height+1), format, t.Value) t.Left.print(height + 1) } That is what will be displayed.\nGet all values with the same level from BST While the function BreadthFirstTraversal returns an array of tree\u0026rsquo;s values by levels, the GetLevel function returns a map, where map\u0026rsquo;s keys are tree\u0026rsquo;s levels, and map\u0026rsquo;s values are arrays of all the nodes\u0026rsquo; values on each level.\ntype levelValue map[int][]int func (t *treeNode) GetLevel(level int, m *levelValue) levelValue { (*m)[level] = append((*m)[level],t.Value) if t.Left == nil \u0026amp;\u0026amp; t.Right == nil { return *m } level = level + 1 if t.Left == nil { return t.Right.GetLevel(level, m) } if t.Right == nil { return t.Left.GetLevel(level, m) } t.Left.GetLevel(level, m) t.Right.GetLevel(level, m) return *m } Such as\n Level 0: 8 Level 1: 3 10 Level 2: 1 6 14 Level 3: 4 7 13  Print left view of BST Left view of a Binary Tree is a set of nodes visible when tree is visited from left side.\nfunc (t *treeNode) printLeftView(root *treeNode) { if t == nil { return } fmt.Println(t.Value) left(root) } func left(t *treeNode) { if t == nil { return } if t.Left != nil { fmt.Println(t.Left.Value) } left(t.Left) left(t.Right) } Return: 8 3 1 4 13\nFind Inorder predecessor and successor for a given key in BST In a given BST highest element on the left subtree is the Predecessor and lowest element on the right subtree is the Successor of the given node.\n1. Finding Predecessor\n// Find Inorder predecessor successor for a given key in BST // Return -1 if there is not any func (t *treeNode) FindPredecessor(key int) int { if t == nil { panic(\u0026#34;root is nil\u0026#34;) } node := t.nodeSearch(key) if node == nil { panic(\u0026#34;key does not exist in the tree\u0026#34;) } parent := t.parent(node) if node.Left == nil { if node.Value == t.Value { return -1 } if node.Value \u0026lt; t.Value { if node.Value \u0026lt; parent.Value { return -1 } return parent.Value //panic(\u0026#34;No predecessor\u0026#34;)  } if node.Value \u0026gt; t.Value { if node.Value \u0026gt; parent.Value { return parent.Value } return t.parent(parent).Value } } return FetchMax(node.Left) } // Find parent node for a given node in BST func (t *treeNode) parent(node *treeNode) *treeNode { if t == nil { fmt.Println(\u0026#34;Tree does not exist\u0026#34;) return nil } if t == node { fmt.Println(\u0026#34;Node is root node, that has no parent\u0026#34;) return nil } if node.Value \u0026lt; t.Value { if t.Left == node { return t } return t.Left.parent(node) } if t.Right == node { return t } return t.Right.parent(node) } 2. Finding Successor\n// Find Inorder successor for a given key in BST func (t *treeNode) FindSuccessor(key int) int { if t == nil { panic(\u0026#34;root is nil\u0026#34;) } node := t.nodeSearch(key) if node == nil { panic(\u0026#34;key does not exist in the tree\u0026#34;) } parent := t.parent(node) if node.Right == nil { if node.Value == t.Value { return -1 } if node.Value \u0026gt; t.Value { //panic(\u0026#34;No successor\u0026#34;)  if node == parent.Right { return -1 } return parent.Value } if node.Value \u0026lt; t.Value { if node == parent.Left { return parent.Value } return t.parent(parent).Value } } return FetchMin(node.Right) } References  Binary Trees  ","href":"/docs/bst-others/","title":"Binary Search Tree - Part III"},{"content":"Source code\nA traversal is a process of visiting all the nodes in a tree. We can categorise tree\u0026rsquo;s traversal algorithms into 2 groups: depth-first traversal and breadth-first traversal.\n Depth-first traversal: includes PreOrder traversal, InOrder traversal, and PostOrder traversal. Breadth-first traversal: the level order traversal. In this traversal, we visit the node by levels from top to bottom, and from left to right.  Let have a look at implementations of those traversal.\nPreOrder traversal  Visit root node Visit all the nodes in the left subtree Visit all the nodes in the right subtree  func (t *treeNode) PreorderTraversal() { if t == nil { return } fmt.Println(t.Value) t.Left.PreorderTraversal() t.Right.PreorderTraversal() } Return: 8 3 1 6 4 7 10 14 13\nInOrder traversal  First, visit all the nodes in the left subtree Then the root node Visit all the nodes in the right subtree  func (t *treeNode) InOrderTraversal() { if t == nil { return } t.Left.InOrderTraversal() fmt.Println(t.Value) t.Right.InOrderTraversal() } Return: 1 3 4 6 7 8 10 13 14\nPostOrder traversal  Visit all the nodes in the left subtree Visit all the nodes in the right subtree Visit the root node  func (t *treeNode) PostOrderTraversal() { if t == nil { return } t.Left.PostOrderTraversal() t.Right.PostOrderTraversal() fmt.Println(t.Value) } Return: 1 4 7 6 3 13 14 10 8\nBreadth first traversal func (t *treeNode) BreadthFirst() []int { if t == nil { return nil } var queue []*treeNode queue = append(queue, t) var res []int res = levelOrder(queue, res) fmt.Println(res) return res } func levelOrder(queue []*treeNode, res []int) []int { if len(queue) == 0 { return res } n := len(queue) for i := 0; i \u0026lt; n; i++ { res = append(res, queue[i].Value) if queue[i].Left != nil { queue = append(queue, queue[i].Left) } if queue[i].Right != nil { queue = append(queue, queue[i].Right) } } return levelOrder(queue[n:], res) } Return: 8 3 10 1 6 14 4 7 13\nReferences  Binary Trees  ","href":"/docs/traverse-bst/","title":"Binary Search Tree - Part II"},{"content":"","href":"/tags/breadth-first-traversal/","title":"breadth-first traversal"},{"content":"","href":"/tags/depth-first-traversal/","title":"depth-first traversal"},{"content":"","href":"/tags/traverse/","title":"traverse"},{"content":"Source code\nIntroduction A Binary Tree is a tree data structure, that consists of nodes. The topmost node in the tree is the root. Every node in a Binary Tree has maximum 2 children, which are referred to as left and right child. A leaf is a node that both its left and right subtrees are empty. A node with only one subtree is called half-leaf. A parent of a node is the node immediately above it.\ntype treeNode struct { Left *treeNode Right *treeNode Value int } A common operations in a binary tree are searching, insertion, and deletion. To perform those operations in binary search tree, we need to traverse all elements of the tree. Therefore, in the worst case, the time complexity of those operation is \\( O(n) \\).\nA Binary Search Tree (BST) is a binary tree where values of the left node and right node are less than and greater than value of its parent, correspondingly.\nOperations in BST has time complexity is \\( O(h) \\), where \\( h \\) is height of the BST. In the worst case where \\( h \\) is equal number of elements in the tree, the worst case complexity is \\( O(n) \\). A BST that is built from a sorted list of keys will produce worst case performance.\nSearching an element from BST Searching for an element from BST is performed by comparing the search element with the value of root node.\n If both are matched, then return the root node; If search element is smaller, continue searching on the left subtree; If search element is larger, continue searching on the right subtree; If there is no such element found, display \u0026ldquo;Element is not found\u0026rdquo;.  func (t *treeNode) nodeSearch(data int) *treeNode { if t == nil { fmt.Println(\u0026#34;Tree is empty\u0026#34;) return nil } if data == t.Value { return t } if data \u0026lt; t.Value { if t.Left == nil { fmt.Println(\u0026#34;Element is not found\u0026#34;) return nil } return t.Left.nodeSearch(data) } if t.Right == nil { fmt.Println(\u0026#34;Element is not found\u0026#34;) return nil } return t.Right.nodeSearch(data) } Insert an element to BST Inserting an element to a BST with the same logic as searching for an element. It is noted that the element is inserted to a leaf node only.\nfunc (t *treeNode) Insert(data int) { if t == nil { t = \u0026amp;treeNode{Value: data} return } if data == t.Value { fmt.Println(\u0026#34;Node already exists\u0026#34;) return } if data \u0026lt; t.Value { if t.Left == nil { t.Left = \u0026amp;treeNode{Value: data} return } t.Left.Insert(data) return } if data \u0026gt; t.Value { if t.Right == nil { t.Right = \u0026amp;treeNode{Value: data} return } t.Right.Insert(data) } } Delete Node  Node to be deleted is a leaf: Removing this node from the tree by setting its parent points to nil. Node to be deleted is half leaf: setting its parent points to its child Node to be deleted has two children:  Find InOrder successor of the node; Copy contents of the InOrder successor to the node; Delete the InOrder successor.    It is noted that InOrder predecessor can also be used.\n/* ------------------------------------------------------------------------------ DELETE Delete a node from BST Helper functions: PointToNil and transplant ---------------------------------------------------------------------------------*/ func (t *treeNode) DeleteNode(root *treeNode, data int) { if root == nil { return } node := root.nodeSearch(data) if node == nil { panic(\u0026#34;key does not exist in the tree\u0026#34;) } parent := t.parent(node) // delete leaf \tif node.Left == nil \u0026amp;\u0026amp; node.Right == nil { PointToNil(node, parent) return } if node.Left == nil { t.transplant(node, node.Right) return } if node.Right == nil { t.transplant(node, node.Left) return } nodeSuccessor := root.FindSuccessor(data) node.Value = nodeSuccessor root.DeleteNode(node.Right, nodeSuccessor) return } func PointToNil(node, parent *treeNode) { if node == parent.Left { parent.Left = nil return } if node == parent.Right { parent.Right = nil return } } func (t *treeNode) transplant(n1, n2 *treeNode) { parent := t.parent(n1) // n1 is root \tif parent == nil { t.Value = n2.Value t.Right, t.Left = n2.Right, n2.Left return } if n1 == parent.Left { parent.Left = n2 return } if n1 == parent.Right { parent.Right = n2 return } } Finding Successor\nHelper function is parent()\n// Find InOrder successor for a given key in BST func (t *treeNode) FindSuccessor(key int) int { if t == nil { panic(\u0026#34;root is nil\u0026#34;) } node := t.nodeSearch(key) if node == nil { panic(\u0026#34;key does not exist in the tree\u0026#34;) } parent := t.parent(node) if node.Right == nil { if node.Value == t.Value { return -1 } if node.Value \u0026gt; t.Value { //panic(\u0026#34;No successor\u0026#34;)  if node == parent.Right { return -1 } return parent.Value } if node.Value \u0026lt; t.Value { if node == parent.Left { return parent.Value } return t.parent(parent).Value } } return FetchMin(node.Right) } // Find parent node for a given node in BST func (t *treeNode) parent(node *treeNode) *treeNode { if t == nil { fmt.Println(\u0026#34;Tree does not exist\u0026#34;) return nil } if t == node { fmt.Println(\u0026#34;Node is root node, that has no parent\u0026#34;) return nil } if node.Value \u0026lt; t.Value { if t.Left == node { return t } return t.Left.parent(node) } if t.Right == node { return t } return t.Right.parent(node) } For example, deleting a leaf node - Node 1\nDeleting a half node - Node 14\nDeleting a full node - Node 6\nDeleting root node - Node 8\nReferences  Binary Trees  ","href":"/docs/bst/","title":"Binary Search Tree - Part I"},{"content":"","href":"/tags/api/","title":"API"},{"content":"","href":"/tags/game/","title":"game"},{"content":"","href":"/tags/gcp/","title":"GCP"},{"content":"Source code\nDescription This is a very simple game modified from Flappy Gopher game from Ebiten. It is written in Go using Ebiten library.\nMira is running her scooter. She is going to meet objects on her way, and jumping over them is the only way to go pass. Every time when she successfully avoids an object she will get one point.\nHow to play Press space key or left-click when you want to jump.\nSome modifications that have been made  Changing Gopher image to Mira image. The new image is stored locally in personal github folder  localsrc \u0026#34;github.com/tracey7d4/mirajump/resources/images  Un-rotating image during jumping period Deleting upper pipes Increasing gap between two adjacent pipes Making pipes\u0026rsquo; height fixed Changing to automatically running on the ground Jumping only once at a time. Another jump can only be done as long as Mira is on the ground.  ","href":"/project/mirajump/","title":"Mira Jump"},{"content":"","href":"/tags/project/","title":"project"},{"content":"Source code\nIn this application, we will discuss about stockbot that returns stock prices of a company. The architecture is as follows.\nFor one who comes to this repository first, I have another repository call weatherbot in which I have described step by step how to build a weatherbot for querying weather conditon of a location. Most of the steps of implementation for two bots are similar, including building a Slack bot user, subscribing to app mentioned event, creating a Go function which is a HTTP handler. So please refer to that application for more details. In this application, I only discuss the difference in Go function. In particular, we will have a look at getStock(), which is used to make a call out to third-party API, receive the response, extract and format the information.\nThe getQuote() is as follows.\nfunc getQuote(sym string) (string, error) { sym = strings.ToUpper(sym) fhUrl := fmt.Sprintf(\u0026#34;https://finnhub.io/api/v1/quote?symbol=%s\u0026#34;, sym) resp, err := http.Get(fhUrl) if err != nil { return \u0026#34;\u0026#34;, err } defer func(){ _ = resp.Body.Close() }() body, err := ioutil.ReadAll(resp.Body) m := make(map[string]float32) err = json.Unmarshal(body, \u0026amp;m) if err != nil { return \u0026#34;\u0026#34;, err } fhUrlForName := fmt.Sprintf(\u0026#34;https://finnhub.io/api/v1/stock/profile2?symbol=%s\u0026#34;, sym) resp, err = http.Get(fhUrlForName) if err != nil { return \u0026#34;\u0026#34;, err } defer func(){ _ = resp.Body.Close() }() body, err = ioutil.ReadAll(resp.Body) m1 := make(map[string]string) err = json.Unmarshal(body, \u0026amp;m1) if err != nil { return \u0026#34;\u0026#34;, err } var s string if len(m) == 1 { s = \u0026#34;_\u0026#34; + sym + \u0026#34; is not a valid trading name_\u0026#34; } else { s = \u0026#34;*\u0026#34; + m1[\u0026#34;name\u0026#34;] + \u0026#34; (\u0026#34; + sym + \u0026#34;) \u0026#34; + \u0026#34; Stock Price* \\n\u0026#34; + \u0026#34;_current_: $\u0026#34; + fmt.Sprintf(\u0026#34;%.2f\u0026#34;, m[\u0026#34;c\u0026#34;]) + \u0026#34;\\n\u0026#34; + \u0026#34;_high_: $\u0026#34; + fmt.Sprintf(\u0026#34;%.2f\u0026#34;, m[\u0026#34;h\u0026#34;]) + \u0026#34;\\n\u0026#34; + \u0026#34;_low_: $\u0026#34; + fmt.Sprintf(\u0026#34;%.2f\u0026#34;, m[\u0026#34;l\u0026#34;]) + \u0026#34;\\n\u0026#34; + \u0026#34;_open_: $\u0026#34; + fmt.Sprintf(\u0026#34;%.2f\u0026#34;, m[\u0026#34;o\u0026#34;]) + \u0026#34;\\n\u0026#34; + \u0026#34;_previous close_: $\u0026#34; + fmt.Sprintf(\u0026#34;%.2f\u0026#34;, m[\u0026#34;pc\u0026#34;]) + \u0026#34;\\n\u0026#34; + \u0026#34;_timestamp_: \u0026#34; + time.Now().UTC().String() } return s, nil } I use http://finnhub.io API this time for getting stock value of a company by its ticker symbol. You can find its API documentation in here.\nI also want to display the company trading name along with its ticker symbol, so I make another call for getting the company name.\nhttps://finnhub.io/api/v1/stock/profile2?symbol=\u0026lt;ticker symbol\u0026gt; Now let\u0026rsquo;s deploy our Go function\ngcloud functions deploy AppStockMentionHandler --runtime go111 --trigger-http\rWhen you see that your function has been successfully deployed, go to a Slack Channel and call your bot, remember to mention its name.\n@stockbot aapl\rHope you enjoy your bots.\nAPI reference  Stock API Documentation Weather bot repository  ","href":"/project/stockbot/","title":"Simple Slack bot in Go using event API - Stock Bot"},{"content":"","href":"/tags/slack/","title":"slack"},{"content":"Source code\nIn this repository, I\u0026rsquo;m going to create a weatherbot for querying weather condition of a given location. The idea of writing a Slack bot in Go was inspired by rapidloop\u0026rsquo;s slackbot for RTM API. At the moment, Slack platform provides a range of APIs that Slack apps can access to including events API, web API, Audit Logs APIs beside RTM API which was used in rapidloop\u0026rsquo;s implementation. As RTM API is being phased out in favour of events API, in this application, events API will be used.\nArchitecture The architecture of the application can be seen in the diagram below.\nWhen a bot is mentioned in Slack App, an event is created on Slack Event API. That event will trigger a call out to a cloud function.The cloud function was written in Go and hosted on Google Cloud Platform (GCP). The function gets the location from the request, calls out to a third-party API, which is openweathermap in this case, to get the weather information. The function then formats the final message with that information before sending it back to Slack API to display in Slack App.\nCreating such bot required the following steps\n  Build a Slack Bot User that subscribes to app_mention event\n  Create a project on GCP to deploy the cloud function.\n  Create a Go function which is a HTTP handler that responds to events triggered by Slack bot\n  Implementation   Build a Slack Bot User\nIt will need a Slack workspace as well to deploy the bot. So either an existing workspace or a new one is required. In Slack API page, let\u0026rsquo;s create a new app by clicking on the Create New App button. Next, create a Bot User for it. Invite your bot to Slack channels where you want to interact with it. Follow the link for more details about bot users and how to build one.\nWe also need to subscribe to app_mention event. This subscription allows your bot to response to users\u0026rsquo; requests that mention its name.\n  Create a project on GCP\nA GCP account is all we need to create a Project on GCP. Follow the instruction of setting up a GCP Project here.\n  Create a Go function\nThe final step is writing a Go function for your bot that will be deployed on to GCP. If you haven\u0026rsquo;t worked with GCP before, there is an example of Hello, World cloud function in the link given above, which can serve as an excellent starting point.\nOur Go function is routed with each request made to the cloud function, and a response to an incoming request will be written to the http.ResponseWriter. More details on this will be provided in a later section.\nTo make our bot respond to the request when its name is mentioned, we need to subscribe to the app_mention event.\nA. Event Subscription\nGo to Your Apps at https://api.slack.com/apps, choose the bot, go to Event Subscription configuration under Features section, then turn Enable Events to On.\nAn Event Request URL must be confirmed before subscribing to any events and saving the form. Right after you type in a URL, Slack will automatically send out an attribution that includes token, challenge, and type fields as shown in figure below. It is noted that this figure is taken from Slack usages guide. Yours will look different.\nThe requirement is that our endpoint will respond back with challenge attribute value. In other words, our function needs to catch the challenge value and send it back to Slack for the first time running. Following is the function that performs the task.\nfunc AppWeatherMentionHandler(w http.ResponseWriter, r *http.Request) { // get the request body  defer func() { _ = r.Body.Close() }() body, _ := ioutil.ReadAll(r.Body) m := make(map[string]interface{}) err := json.Unmarshal(body, \u0026amp;m) if err != nil { _, _ = fmt.Fprintf(w, \u0026#34;error unmarshalling body: %v\u0026#34;, err) return } fmt.Fprintf(w, \u0026#34;%s\u0026#34;, m[\u0026#34;challenge\u0026#34;]) } Deploy this function by following command\ngcloud functions deploy AppWeatherMentionHandler --runtime go111 --trigger-http\rAnswer y to the question about unauthenticated access. In the returning log you can see the URL that points to your newly created cloud function as an endpoint for your web service. Copy and paste this link to the Request URL panel on web Slack app till the field turned to Verified\nOnce the URL is successfully verified, click on Add Bot User Event, choose app_mention event and then save the form Save changes.\nWe have already done with subscribing an event for our bot. Now come back with our Go function for weatherbot.\nB. Slack Weather Bot\nOur Go function AppWeatherMentionHandler() is a HTTP handler that does the following tasks\n Get the city name from the JSON payload describing the event and assign it to a variable city; Call a local function getWeather() to get weather message;  get the weather from openweathermap format the return message   Call sendMessage() function to display the response in Slack channels.  In the first step, the JSON payload from Slack API will look like this.\n\u0026#34;token\u0026#34;: \u0026#34;*****************************\u0026#34;, \u0026#34;team_id\u0026#34;: \u0026#34;**************\u0026#34;, \u0026#34;api_app_id\u0026#34;: \u0026#34;********\u0026#34;, \u0026#34;event\u0026#34;: { \u0026#34;client_msg_id\u0026#34;: \u0026#34;************************\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;app_mention\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;\u0026lt;@ your bot user_ID\u0026gt; Melbourne, Au\u0026#34;, \u0026#34;user\u0026#34;: \u0026#34;************\u0026#34;, \u0026#34;ts\u0026#34;: \u0026#34;1592101177.000800\u0026#34;, .... We\u0026rsquo;re going to unmarshall this JSON into a map to extract the information of interest. Apart from the city name I also need the token and channel fields as they are required to send the message back to Slack later.\nbody, _ := ioutil.ReadAll(r.Body) m := make(map[string]interface{}) err := json.Unmarshal(body, \u0026amp;m) if err != nil { _, _ = fmt.Fprintf(w, \u0026#34;error unmarshalling body: %v\u0026#34;, err) return } m1 := m[\u0026#34;event\u0026#34;].(map[string]interface{}) text := fmt.Sprintf(\u0026#34;%v\u0026#34;, m1[\u0026#34;text\u0026#34;]) str := strings.Split(text, \u0026#34;\u0026lt;bot user ID\u0026gt;\u0026#34;) city := strings.Trim(str[1], \u0026#34; \u0026#34;) channel := fmt.Sprintf(\u0026#34;%v\u0026#34;, m1[\u0026#34;channel\u0026#34;]) token := \u0026#34;User\u0026#39;s Slack Bot Token\u0026#34; Call getWeather() with city variable as an input.\nweather, err := getWeather(city) I am using openweathermap.org API to get weather information. This API requires an appID, and all you need to do to get one is signing up an account on its website. You can check API documentation for current weather here. To get current weather of a city by name with returned values in cubic metric you need to call the following endpoint.\nhttp://api.openweathermap.org/data/2.5/weather?q=\u0026lt;city_name\u0026gt;\u0026amp;units=metric\u0026amp;APPID=\u0026lt;appID\u0026gt; If the data for that city could not be found, {\u0026quot;cod\u0026quot;:\u0026quot;404\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;city not found\u0026quot;} is returned. In this case, our bot will display City \u0026lt;city_name\u0026gt; is not found to the user. Otherwise, weather information will be extracted from the response and put into a formatted Slack message, which will subsequently be sent back to Slack when calling sendMessage().\nerr = sendMessage(token, channel, weather) if err != nil { fmt.Fprintf(w, \u0026#34;error: %v\u0026#34;, err) } As Slack supports formatting text object, the message can be prettied by using some special symbols such as * (for Bold), _ (for Italic). I even created an emojimap to add some weather emoji icons.\nOur AppWeatherMentionHandler function is now ready to deploy to GCP.\ngcloud functions deploy AppWeatherMentionHandler --runtime go111 --trigger-http\rOnce it is successfully deployed, you can try the bot out on your Slack channel. For instance, if you want to know how the weather at Melbourne, Australia is, you mention your bot like follows.\n@weatherbot Melbourne, Au\rAnd this is what will be displayed in your Slack channel\n  Conclusion Well done! Now you have a working bot handy for checking weather. Follow this link for another amazing bot that allows you to quote stock price.\nReferences  Rapid loop slackbot for RTM API Slack API Slack Event API Google Cloud Platform openweathermap API Create a Slack App Slack Bot users App_mention event GCP cloud function example Current Weather API doc Formatting Text Weather condition Emoji Golang http Markdown Basic writting and formatting on Gibthub Stockbot repository Icons made by Dave Gandyfrom www.flaticon.com  ","href":"/project/weatherbot/","title":"Simple Slack bot in Go using event API - Weather Bot"},{"content":"","href":"/tags/channel/","title":"channel"},{"content":"","href":"/tags/concurrency/","title":"concurrency"},{"content":"Source code\nI found that it is an excellent example about Go concurrency and synchronization.\nProblem description There are 5 philosophers having their dinner at a round table with one chopstick between each adjacent pair of philosophers. A philosopher can only eat when they have both left and right chopsticks. In other words, while one philosopher is eating, his two adjacent friends have to wait. After eating he puts both chopsticks down to let the others eat. Under problem constraint, there is a limit number of philosophers that can eat concurrently. And this number may differ in range of 1 to as many as possible.\nThe deadlock may occur when each philosopher simultaneously pickups one chopstick and waits for another chopsticks forever.\nA host which executes in its own goroutine is introduced to resolve the deadlock situation. The host plays a role on coordinating the dining process. In order to give a philosopher permission to eat, host needs to check for all the required conditions, including current status of two adjacent of that philosopher and how many philosophers are eating at that time.\nImplementation Note: This design is scalable, i.e number of philosophers, number of courses per Philosopher, and number philosophers that eat concurrently can be changed.\nconst ( noP = 5 //number of Philosophers \tnoCoursesPerP = 3 // Number of courses per Philosophers \tnoPEatAtOneTime = 2 // number of Philosophers eating concurrently ) We use goroutines to let functions run concurrently, and channels to communicate among goroutines. Firstly, to make sure only one Philosopher can access left and right chopsticks at a time, we use sync.Mutex that allows Philosopher locking the resources while eating and unlocking them after finishing eating. Secondly, we use sync.WaitGroup to wait for all goroutines to finish before main goroutine executes. After finishing its task, a goroutine will notify the WaitGroup that it\u0026rsquo;s done wg.Done(). The WaitGroup counter increases by one wg.Add(1) every time a goroutine is launched, and decreases by one every time receiving notification wg.Done() from a goroutine. So the WaitGroup counter will go back to 0 until all the goroutines notify they\u0026rsquo;re done.\nWe create 3 new types: Chopstick, Philosopher, and Host as follows\ntype Chopstick struct { sync.Mutex } type Philosopher struct { id int leftCS *Chopstick rightCS *Chopstick permission \u0026lt;-chan bool notifyHostIAmDone chan\u0026lt;- int courses int } type Host struct { totalCourses int //so host knows when to stop while all P have finished all courses \tPStatus map[int]Status noEating int pFinishedEating \u0026lt;-chan int } Next, we define method for each type. In particular, the type Philosopher with an eatmethod, and type Host with coordinate method have been declared as follows\nfunc (p *Philosopher) eat(wg *sync.WaitGroup) { for p.courses \u0026gt; 0 { // get permission from Host \t\u0026lt;-p.permission // lock the resources \tp.leftCS.Lock() p.rightCS.Lock() // process: eating --- finishing \tfmt.Printf(\u0026#34;P %v started eating\\n\u0026#34;, p.id) p.courses-- time.Sleep(10 * time.Millisecond) fmt.Printf(\u0026#34;P %v finished eating. Remaining courses %v\\n\u0026#34;, p.id, p.courses) //unlock the resources \tp.leftCS.Unlock() p.rightCS.Unlock() //notify Host \tp.notifyHostIAmDone \u0026lt;- p.id } // finished all course \twg.Done() } func (h *Host) coordinate(wg *sync.WaitGroup) { for h.totalCourses \u0026gt; 0 { select { case id := \u0026lt;-h.pFinishedEating: m := h.PStatus[id] m.eating = false h.PStatus[id] = m h.totalCourses-- h.noEating-- default: h.letThemEat() } } wg.Done() } Each time a Philosopher finishes eating, he will notify the host by sending out his ID, so that the host can update his status. Status is a type that contains several fields as follows\ntype Status struct { eating bool courses int eatingPermission chan\u0026lt;- bool } After giving eating permission to a Philosopher, the host once again updates the status of that Philosopher. At the result, the host know the status of all Philosopher at a current of time, so that he can coordinate the dining process.\n","href":"/docs/dining-philosopher/","title":"Dining Philosopher problem in Go"},{"content":"","href":"/tags/config/","title":"Configuration"},{"content":"","href":"/tags/og/","title":"Opengraph"},{"content":"","href":"/page/","title":"Pages"},{"content":"","href":"/search/","title":"Search"},{"content":"","href":"/series/","title":"Series"}]
