<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My Posts on Tracey Hoang</title>
    <link>http://www.example.com/docs/</link>
    <description>Recent content in My Posts on Tracey Hoang</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 06 Nov 2020 14:00:00 +1100</lastBuildDate>
    
	<atom:link href="http://www.example.com/docs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Longest Common Subsequence (LCS) - Dynamic Programming</title>
      <link>http://www.example.com/docs/lcs/</link>
      <pubDate>Fri, 06 Nov 2020 14:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/lcs/</guid>
      <description>Source code
We are going to solve this problem by using Dynamic Programming with memoisation and tabulation techniques.
Problem Description The longest common subsequence (LCS) problem is to compute the length of a longest subsequence common to all given sequences. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous. For example, the LCS of 2 sequence {1,2,3} and {1,3,5} is {1,3}, and has the length is 2.</description>
    </item>
    
    <item>
      <title>Majority Element Of An Array</title>
      <link>http://www.example.com/docs/majorityelement/</link>
      <pubDate>Sat, 24 Oct 2020 22:20:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/majorityelement/</guid>
      <description>Source code
Problem description An array is said to have a majority element if more than half of its elements are the same.
Given a non-empty array arr. Check to see if the array has a majority element.
Implementation Let&amp;rsquo;s have a look at some approaches of solving the given problem.
1- Brute Force algorithm This approach is to find the occurrences of each element. As soon as there is an occurrence of an element is greater than a half, we know that this array has majority element and then return true.</description>
    </item>
    
    <item>
      <title>Binary Search</title>
      <link>http://www.example.com/docs/binarysearch/</link>
      <pubDate>Sat, 24 Oct 2020 22:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/binarysearch/</guid>
      <description>Source code
A linear search is a searching algorithm that find the position of an element from a list by sequentially comparing the elements of the list until finding the matching element. This is the simplest searching algorithm and is practical when the list has only a few elements or when performing a single search in an unsorted array. Linear search has worst-case and average-case time complexity \( O(n) \), and best case time complexity \( O(1) \).</description>
    </item>
    
    <item>
      <title>Coin Change Problem - Dynamic Programming</title>
      <link>http://www.example.com/docs/dynamicprogramming/</link>
      <pubDate>Wed, 21 Oct 2020 16:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/dynamicprogramming/</guid>
      <description>Source code
Dynamic programming solves the complex problem by breaking it into simpler sub-problems, solving each of those once, and storing their solution for later use. Dynamic programming uses memoisation and tabulation technique for improving its performance.
Memoisation is a technique of optimisation by storing the solutions of function calls and returning the cached result when the same inputs are called again.
Tabulation is an approach by first filling up a table, then solving the original problem based on the solutions in this table.</description>
    </item>
    
    <item>
      <title>Recursion in Go</title>
      <link>http://www.example.com/docs/superdigitrecursion/</link>
      <pubDate>Wed, 21 Oct 2020 14:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/superdigitrecursion/</guid>
      <description>Source code
Golang supports recursion, that allows function to call itself. A recursive function has a base case which is the final executable statement in recursion. The base case is needed to be defined carefully, otherwise the program will go on to infinite loop.
Let&amp;rsquo;s consider the following example that applied recursive function directly.
Our program is to find super digit on an given integer x, which is defined as follows.</description>
    </item>
    
    <item>
      <title>Find Pairs With the Same Difference from an Array- Map Example</title>
      <link>http://www.example.com/docs/mapexample/</link>
      <pubDate>Wed, 21 Oct 2020 11:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/mapexample/</guid>
      <description>Source code
Go map Go map is built-in type that implements a hash table - a very useful data structure in computer science. A Go map type is defined as
map[Key]Value We use make function to initialise a map, and also need to define types for map&amp;rsquo;s Key and Value. For example, initialisation of a map of string keys to float64 values is as follows.
m := make(map[string]float64) Let have a quick look at an small example about inserting, looking up, and deteting data from a map.</description>
    </item>
    
    <item>
      <title>Compose the largest number out of given set of integers</title>
      <link>http://www.example.com/docs/modifiedmergesort/</link>
      <pubDate>Tue, 20 Oct 2020 15:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/modifiedmergesort/</guid>
      <description>Source code
We are given an array of positive integers, and our task is arranging them in a way that yields largest value.
In case the given array consists of all single-digit numbers, we can achieve the largest value easily just by composing the number from a descending sorted array. All what we need to do is sorting the given array in descending order by applying any sorting algorithms.
But how about in the case that given array consists of arbitrary positive integers?</description>
    </item>
    
    <item>
      <title>Sorting Algorithms</title>
      <link>http://www.example.com/docs/sortingalgorithms/</link>
      <pubDate>Tue, 20 Oct 2020 13:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/sortingalgorithms/</guid>
      <description>Source code
We are going to have a look at several sorting algorithms, their implementation, and their performance. In particular, we will discuss about Bubble Sort, Insertion Sort, and Merge Sort.
1- Bubble Sort Bubble Sort is a sorting algorithm that repeatedly swap the adjacent elements if they are in wrong order. It repeatedly pass through the list until the list is sorted.
&amp;ldquo;File:Bubble-sort-example-300px.gif&amp;rdquo; by Swfung8 is licensed under CC BY-SA 3.</description>
    </item>
    
    <item>
      <title>Nothing more than Math</title>
      <link>http://www.example.com/docs/mathprob/</link>
      <pubDate>Mon, 19 Oct 2020 22:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/mathprob/</guid>
      <description>Source code
This post is about some problems that can be solved easily only by using math formula.
1- Greatest common divisor and Least Common Multiple The greatest common divisor \( GCD(a,b) \) of two non-negative integers \( a \) and \( b \) (which are not both equal to 0) is the greatest integer that divides both \( a \) and \( b \).
The least common multiple of two positive integers \( a \) and \( b \) is the least positive integer that is divisible by both \( a \) and \( b \).</description>
    </item>
    
    <item>
      <title>Area and Perimeter of a Geometry - Interface Example</title>
      <link>http://www.example.com/docs/interfaceexample/</link>
      <pubDate>Mon, 19 Oct 2020 14:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/interfaceexample/</guid>
      <description>Source code
This is an example of struct, method, and interface.
I define an interface named geometry that has area() and perim() method signatures.
type geometry interface { area() float64 perim() float64 } I also define 3 other types circle, rectangle and triangle that implement geometry interface. For example, type circle implements all the geometry interface methods as follows.
type circle struct { radius float64 } func (c circle) area() float64 { return math.</description>
    </item>
    
    <item>
      <title>Balanced Binary Search Tree - AVL Tree</title>
      <link>http://www.example.com/docs/balancedbst/</link>
      <pubDate>Sat, 17 Oct 2020 23:10:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/balancedbst/</guid>
      <description>Source code
Introduction AVL tree is a height-balanced binary search tree (BST). In an AVL tree, every node maintains a balance factor, which is defined as follows
balance_factor := height(left_subtree) - height(right_subtree)According to definition of a balanced tree, the balance factor of every node in the AVL tree is either -1, 0, or 1. When an insertion or deletion operation is performed, the tree&amp;rsquo;s height may change, so do the balance factors at nodes.</description>
    </item>
    
    <item>
      <title>Binary Search Tree - Part III</title>
      <link>http://www.example.com/docs/bst-others/</link>
      <pubDate>Sat, 17 Oct 2020 23:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/bst-others/</guid>
      <description>Source code
Fetch maximum value Maximum value of a BST is the value of the most right node
func FetchMax(t *treeNode) int { if t.Right == nil { return t.Value } return FetchMax(t.Right) } Return value: 14
Fetch minimum value Minimum value of a BST is the value of the most left node
func FetchMin(t *treeNode) int { if t.Left == nil { return t.Value } return FetchMin(t.Left) } Return: 1</description>
    </item>
    
    <item>
      <title>Binary Search Tree - Part II</title>
      <link>http://www.example.com/docs/traverse-bst/</link>
      <pubDate>Sat, 17 Oct 2020 22:30:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/traverse-bst/</guid>
      <description>Source code
A traversal is a process of visiting all the nodes in a tree. We can categorise tree&amp;rsquo;s traversal algorithms into 2 groups: depth-first traversal and breadth-first traversal.
 Depth-first traversal: includes PreOrder traversal, InOrder traversal, and PostOrder traversal. Breadth-first traversal: the level order traversal. In this traversal, we visit the node by levels from top to bottom, and from left to right.  Let have a look at implementations of those traversal.</description>
    </item>
    
    <item>
      <title>Binary Search Tree - Part I</title>
      <link>http://www.example.com/docs/bst/</link>
      <pubDate>Sat, 17 Oct 2020 22:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/bst/</guid>
      <description>Source code
Introduction A Binary Tree is a tree data structure, that consists of nodes. The topmost node in the tree is the root. Every node in a Binary Tree has maximum 2 children, which are referred to as left and right child. A leaf is a node that both its left and right subtrees are empty. A node with only one subtree is called half-leaf. A parent of a node is the node immediately above it.</description>
    </item>
    
    <item>
      <title>Dining Philosopher problem in Go</title>
      <link>http://www.example.com/docs/dining-philosopher/</link>
      <pubDate>Fri, 16 Oct 2020 14:00:00 +1000</pubDate>
      
      <guid>http://www.example.com/docs/dining-philosopher/</guid>
      <description>Source code
I found that it is an excellent example about Go concurrency and synchronization.
Problem description There are 5 philosophers having their dinner at a round table with one chopstick between each adjacent pair of philosophers. A philosopher can only eat when they have both left and right chopsticks. In other words, while one philosopher is eating, his two adjacent friends have to wait. After eating he puts both chopsticks down to let the others eat.</description>
    </item>
    
  </channel>
</rss>