<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>recursive on Tracey Hoang</title>
    <link>http://www.example.com/tags/recursive/</link>
    <description>Recent content in recursive on Tracey Hoang</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 11 Nov 2020 14:00:00 +1100</lastBuildDate>
    
	<atom:link href="http://www.example.com/tags/recursive/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Divide an array into 3 subsets with equal sum - Dynamic Programming</title>
      <link>http://www.example.com/docs/threesubsetequalsum/</link>
      <pubDate>Wed, 11 Nov 2020 14:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/threesubsetequalsum/</guid>
      <description>Source code
Description Given an array arr of n integers (n &amp;gt; 0). Find out that is it possible to divide the given array into three sets with equal sums.
For example, array arr = {1, 1, 2, 2, 3, 3} can be divided into 3 subsets with equal sum = 4 as follows: {1, 3}, {1, 3} and {2, 2}; while array arr = {1, 1, 2} can not be divided into such 3 subsets.</description>
    </item>
    
    <item>
      <title>Longest Common Subsequence (LCS) - Dynamic Programming</title>
      <link>http://www.example.com/docs/lcs/</link>
      <pubDate>Fri, 06 Nov 2020 14:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/lcs/</guid>
      <description>Source code
We are going to solve this problem by using Dynamic Programming with memoisation and tabulation techniques.
Problem Description The longest common subsequence (LCS) problem is to compute the length of a longest subsequence common to all given sequences. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous. For example, the LCS of two sequence {1,2,3} and {1,3,5} is {1,3}, and has the length is 2.</description>
    </item>
    
    <item>
      <title>Majority Element Of An Array</title>
      <link>http://www.example.com/docs/majorityelement/</link>
      <pubDate>Sat, 24 Oct 2020 22:20:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/majorityelement/</guid>
      <description>Source code
Problem description An array is said to have a majority element if more than half of its elements are the same.
Given a non-empty array arr. Check to see if the array has a majority element.
Implementation Let&amp;rsquo;s have a look at some approaches of solving the given problem.
1- Brute Force algorithm This approach is to find the occurrences of each element. As soon as an occurrence of an element is greater than a half, we know that this array has majority element and then return true.</description>
    </item>
    
    <item>
      <title>Binary Search</title>
      <link>http://www.example.com/docs/binarysearch/</link>
      <pubDate>Sat, 24 Oct 2020 22:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/binarysearch/</guid>
      <description>Source code
Problem description A linear search is a searching algorithm that find the position of an element from an array by sequentially comparing to the elements of the array until finding the matching element. This is the simplest searching algorithm and is not practical for large problem. Linear search has worst case and average case time complexity \( O(n) \), and best case time complexity \( O(1) \). Its space complexity is \( O(1) \).</description>
    </item>
    
    <item>
      <title>Coin Change Problem - Dynamic Programming</title>
      <link>http://www.example.com/docs/dynamicprogramming/</link>
      <pubDate>Wed, 21 Oct 2020 16:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/dynamicprogramming/</guid>
      <description>Source code
Dynamic programming solves the complex problem by breaking it into simpler sub-problems, solving each of those once, and storing their solution for later use. Dynamic programming uses memoisation and tabulation technique for improving its performance.
Memoisation is a technique of optimisation by storing the solutions of function calls and returning the cached result when the same inputs are called again.
Tabulation is an approach by first filling up a table, then solving the original problem based on the solutions in this table.</description>
    </item>
    
    <item>
      <title>Recursion in Go</title>
      <link>http://www.example.com/docs/superdigitrecursion/</link>
      <pubDate>Wed, 21 Oct 2020 14:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/superdigitrecursion/</guid>
      <description>Source code
Golang supports recursion, that allows function to call itself. A recursive function has a base case which is the final executable statement in recursion. The base case is needed to be defined carefully, otherwise the program will go on to infinite loop.
Let&amp;rsquo;s consider the following example that applied recursive function directly.
Our program is to find super digit on an given integer x, which is defined as follows.</description>
    </item>
    
  </channel>
</rss>