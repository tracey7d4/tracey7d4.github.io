<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>example on Tracey Hoang</title>
    <link>http://www.example.com/tags/example/</link>
    <description>Recent content in example on Tracey Hoang</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 19 Oct 2020 14:00:00 +1100</lastBuildDate><atom:link href="http://www.example.com/tags/example/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Interface Example in Go</title>
      <link>http://www.example.com/docs/interfaceexample/</link>
      <pubDate>Mon, 19 Oct 2020 14:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/interfaceexample/</guid>
      <description>Source code
This is an example of struct, method, and interface.
I define an interface named geometry that has area() and perim() method signitures.
type geometry interface { area() float64 perim() float64 } I also define 3 other types circle, rectangle and triangle that implement geometry interface. For example, type circle implements all the geometry interface methods as follows.
type circle struct { radius float64 } func (c circle) area() float64 { return math.</description>
    </item>
    
    <item>
      <title>Balanced Binary Search Tree - AVL Tree</title>
      <link>http://www.example.com/docs/balancedbst/</link>
      <pubDate>Sat, 17 Oct 2020 23:10:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/balancedbst/</guid>
      <description>Source code
Introduction AVL tree is a height-balanced binary search tree (BST). In an AVL tree, every node maintains a balance factor, which is defind as follows
balance_factor := height(left_subtree) - height(right_subtree)According to definition of a balanced tree, the balance factor of every node in the AVL tree is either -1, 0, or 1. When an insertion or deletion operation is performed, the tree&amp;rsquo;s height may change, so do the balance factors at nodes.</description>
    </item>
    
    <item>
      <title>Binary Search Tree - Part III</title>
      <link>http://www.example.com/docs/bst-others/</link>
      <pubDate>Sat, 17 Oct 2020 23:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/bst-others/</guid>
      <description>Source code
Fetch maximum value Maximum value of a BST is the value of the most right node
func FetchMax(t *treeNode) int { if t.Right == nil { return t.Value } return FetchMax(t.Right) } Return value: 14
Fetch minimum value Minimum value of a BST is the value of the most left node
func FetchMin(t *treeNode) int { if t.Left == nil { return t.Value } return FetchMin(t.Left) } Return: 1</description>
    </item>
    
    <item>
      <title>Binary Search Tree - Part II</title>
      <link>http://www.example.com/docs/traverse-bst/</link>
      <pubDate>Sat, 17 Oct 2020 22:30:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/traverse-bst/</guid>
      <description>Source code
A traversal is a process of visiting all the nodes in a tree. We can categorise tree&amp;rsquo;s traversal algorithms into 2 groups: depth-first traversal and breadth-first traversal.
 Depth-first traversal: includes PreOrder traversal, InOrder traversal, and PostOrder traversal. Breadth-first traversal: the level order traversal. In this traversal, we visit the node by levels from top to bottom, and from left to right.  Let have a look at implementations of those traversal.</description>
    </item>
    
    <item>
      <title>Binary Search Tree - Part I</title>
      <link>http://www.example.com/docs/bst/</link>
      <pubDate>Sat, 17 Oct 2020 22:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/bst/</guid>
      <description>Source code
Introduction A Binary Tree is a tree data structure, that consists of nodes. The topmost node in the tree is the root. Every node in a Binary Tree has maximum 2 children, which are referred to as left and right child. A leaf is a node that both its left and right subtrees are empty. A node with only one subtree is called half-leaf. A parent of a node is the node immediately above it.</description>
    </item>
    
    <item>
      <title>Dining Philosopher problem in Go</title>
      <link>http://www.example.com/docs/dining-philosopher/</link>
      <pubDate>Fri, 16 Oct 2020 14:00:00 +1000</pubDate>
      
      <guid>http://www.example.com/docs/dining-philosopher/</guid>
      <description>Source code
I found that it is an excellent example about Go concurrency and synchronization.
Problem description There are 5 philosophers having their dinner at a round table with one chopstick between each adjacent pair of philosophers. A philosopher can only eat when they have both left and right chopsticks. In other words, while one philosopher is eating, his two adjacent friends have to wait. After eating he puts both chopsticks down to let the others eat.</description>
    </item>
    
  </channel>
</rss>
