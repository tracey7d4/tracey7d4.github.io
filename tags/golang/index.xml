<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on Tracey Hoang</title>
    <link>http://www.example.com/tags/golang/</link>
    <description>Recent content in golang on Tracey Hoang</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 18 Nov 2020 12:00:00 +1100</lastBuildDate>
    
	<atom:link href="http://www.example.com/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>http://www.example.com/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.example.com/about/</guid>
      <description>Hello, I&amp;rsquo;m Tracey. I am a self-taught software engineer with applied mathematics background. After going through A Tour of Go, I found that Go was actually a neat and simple language to learn and started to develop more interest in programming. While still in my learning journey, I create this blog to share interesting problems and projects that I have done in Go, as well as some other useful resources.</description>
    </item>
    
    <item>
      <title>Define all maximum of all subarrays of sliding window size k</title>
      <link>http://www.example.com/docs/maxvalueofslidingwindow/</link>
      <pubDate>Wed, 18 Nov 2020 12:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/maxvalueofslidingwindow/</guid>
      <description>Source code
Problem description Given an array of n element. Define the maximum value of every sliding window size k of that array. A window size k of the array is any subarray of k elements of original array.
Algorithm 1. Naive algorithm Naive algorithm is to scan each window separately, and find the maximum value of each window.
Time complexity: \( O(n \times k) \)
Space complexity: \( O(1) \)</description>
    </item>
    
    <item>
      <title>Design a Special Stack that supports finding max/min value in constant time</title>
      <link>http://www.example.com/docs/specialstack/</link>
      <pubDate>Wed, 18 Nov 2020 11:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/specialstack/</guid>
      <description>Source code
Description Our task is to design a stack that supports some operations such as push a key in, pop an element out, and return maximum and minimum values. We also need to make sure all those operations are done in constant of time.
The program lets user type in queries, and only terminates when user stops the program or when user type in &amp;ldquo;stop&amp;rdquo; query.
Algorithm The idea is to use 3 different stacks, one to store the actual elements, the other two are auxiliary stacks to store maximum and minimum elements at current state.</description>
    </item>
    
    <item>
      <title>Check for balanced brackets in a text - Stack</title>
      <link>http://www.example.com/docs/brackets/</link>
      <pubDate>Tue, 17 Nov 2020 21:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/brackets/</guid>
      <description>Source code
Given a text that contains any brackets from the set [], {}, (). Our program is to check whether the text uses brackets correctly. If there are no mistake, print out &amp;ldquo;Balanced&amp;rdquo;. Otherwise, find index of the first unmatched closing brackets, or the last opening bracket without corresponding closing one, and print out &amp;ldquo;Unbalanced at index index&amp;rdquo;.
For example:
[()] &amp;ndash;&amp;gt; Balanced
[(] &amp;ndash;&amp;gt; Unbalanced at index 3</description>
    </item>
    
    <item>
      <title>Define a subarray with largest sum</title>
      <link>http://www.example.com/docs/maxsubarray/</link>
      <pubDate>Wed, 11 Nov 2020 22:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/maxsubarray/</guid>
      <description>Source code
Problem description Given a non-empty array of integers. Find a subarray with the largest sum. A subarray of an array is a subset composed from a contiguous block of original array&amp;rsquo;s elements. The sum of an array is the total sum of its elements.
Input: \( arr = [a_1, a_2, ... , a_n] \), \( n  0 \)
Output: Largest subarray sum maxSum and subarray \( subarr = [a_i, a_{i+1}, .</description>
    </item>
    
    <item>
      <title>Divide an array into 3 subsets with equal sum - Dynamic Programming</title>
      <link>http://www.example.com/docs/threesubsetequalsum/</link>
      <pubDate>Wed, 11 Nov 2020 14:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/threesubsetequalsum/</guid>
      <description>Source code
Description Given an array arr of n integers (n &amp;gt; 0). Our program is to check whether it is possible to divide the given array into three sets with equal sums.
For example, Array arr = {1, 1, 2, 2, 3, 3} can be divided into 3 subsets with equal sum = 4 as follows: {1, 3}, {1, 3} and {2, 2}; while array arr = {1, 1, 2} can not be divided into such 3 subsets.</description>
    </item>
    
    <item>
      <title>Longest Common Subsequence (LCS) - Dynamic Programming</title>
      <link>http://www.example.com/docs/lcs/</link>
      <pubDate>Fri, 06 Nov 2020 14:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/lcs/</guid>
      <description>Source code
We are going to solve this problem by using Dynamic Programming with memoisation and tabulation techniques.
Problem Description The longest common subsequence (LCS) problem is to compute the length of a longest subsequence common to all given sequences. A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous. For example, the LCS of two sequence {1,2,3} and {1,3,5} is {1,3}, and has the length is 2.</description>
    </item>
    
    <item>
      <title>Majority Element Of An Array</title>
      <link>http://www.example.com/docs/majorityelement/</link>
      <pubDate>Sat, 24 Oct 2020 22:20:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/majorityelement/</guid>
      <description>Source code
Problem description An array is said to have a majority element if more than half of its elements are the same.
Given a non-empty array arr. Check to see if the array has a majority element.
Implementation Let&amp;rsquo;s have a look at some approaches of solving the given problem.
1- Brute Force algorithm This approach is to find the occurrences of each element. As soon as there is an occurrence of an element is greater than a half, we know that this array has majority element and then return true.</description>
    </item>
    
    <item>
      <title>Binary Search</title>
      <link>http://www.example.com/docs/binarysearch/</link>
      <pubDate>Sat, 24 Oct 2020 22:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/binarysearch/</guid>
      <description>Source code
A linear search is a searching algorithm that find the position of an element from a list by sequentially comparing the elements of the list until finding the matching element. This is the simplest searching algorithm and is practical when the list has only a few elements or when performing a single search in an unsorted array. Linear search has worst-case and average-case time complexity \( O(n) \), and best case time complexity \( O(1) \).</description>
    </item>
    
    <item>
      <title>Coin Change Problem - Dynamic Programming</title>
      <link>http://www.example.com/docs/dynamicprogramming/</link>
      <pubDate>Wed, 21 Oct 2020 16:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/dynamicprogramming/</guid>
      <description>Source code
Dynamic programming solves the complex problem by breaking it into simpler sub-problems, solving each of those once, and storing their solution for later use. Dynamic programming uses memoisation and tabulation technique for improving its performance.
Memoisation is a technique of optimisation by storing the solutions of function calls and returning the cached result when the same inputs are called again.
Tabulation is an approach by first filling up a table, then solving the original problem based on the solutions in this table.</description>
    </item>
    
    <item>
      <title>Recursion in Go</title>
      <link>http://www.example.com/docs/superdigitrecursion/</link>
      <pubDate>Wed, 21 Oct 2020 14:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/superdigitrecursion/</guid>
      <description>Source code
Golang supports recursion, that allows function to call itself. A recursive function has a base case which is the final executable statement in recursion. The base case is needed to be defined carefully, otherwise the program will go on to infinite loop.
Let&amp;rsquo;s consider the following example that applied recursive function directly.
Our program is to find super digit on an given integer x, which is defined as follows.</description>
    </item>
    
    <item>
      <title>Find Pairs With the Same Difference from an Array- Map Example</title>
      <link>http://www.example.com/docs/mapexample/</link>
      <pubDate>Wed, 21 Oct 2020 11:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/mapexample/</guid>
      <description>Source code
Go map Go map is built-in type that implements a hash table - a very useful data structure in computer science. A Go map type is defined as
map[Key]Value We use make function to initialise a map, and also need to define types for map&amp;rsquo;s Key and Value. For example, initialisation of a map of string keys to float64 values is as follows.
m := make(map[string]float64) Let have a quick look at an small example about inserting, looking up, and deteting data from a map.</description>
    </item>
    
    <item>
      <title>Compose the largest number out of given set of integers</title>
      <link>http://www.example.com/docs/modifiedmergesort/</link>
      <pubDate>Tue, 20 Oct 2020 15:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/modifiedmergesort/</guid>
      <description>Source code
We are given an array of positive integers, and our task is arranging them in a way that yields largest value.
In case the given array consists of all single-digit numbers, we can achieve the largest value easily just by composing the number from a descending sorted array. All what we need to do is sorting the given array in descending order by applying any sorting algorithms.
But how about in the case that given array consists of arbitrary positive integers?</description>
    </item>
    
    <item>
      <title>Sorting Algorithms</title>
      <link>http://www.example.com/docs/sortingalgorithms/</link>
      <pubDate>Tue, 20 Oct 2020 13:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/sortingalgorithms/</guid>
      <description>Source code
We are going to have a look at several sorting algorithms, their implementation, and their performance. In particular, we will discuss about Bubble Sort, Insertion Sort, and Merge Sort.
1- Bubble Sort Bubble Sort is a sorting algorithm that repeatedly swap the adjacent elements if they are in wrong order. It repeatedly pass through the list until the list is sorted.
&amp;ldquo;File:Bubble-sort-example-300px.gif&amp;rdquo; by Swfung8 is licensed under CC BY-SA 3.</description>
    </item>
    
    <item>
      <title>Nothing more than Math</title>
      <link>http://www.example.com/docs/mathprob/</link>
      <pubDate>Mon, 19 Oct 2020 22:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/mathprob/</guid>
      <description>Source code
This post is about some problems that can be solved easily only by using math formula.
1- Greatest common divisor and Least Common Multiple The greatest common divisor \( GCD(a,b) \) of two non-negative integers \( a \) and \( b \) (which are not both equal to 0) is the greatest integer that divides both \( a \) and \( b \).
The least common multiple of two positive integers \( a \) and \( b \) is the least positive integer that is divisible by both \( a \) and \( b \).</description>
    </item>
    
    <item>
      <title>Area and Perimeter of a Geometry - Interface Example</title>
      <link>http://www.example.com/docs/interfaceexample/</link>
      <pubDate>Mon, 19 Oct 2020 14:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/interfaceexample/</guid>
      <description>Source code
This is an example of struct, method, and interface.
I define an interface named geometry that has area() and perim() method signatures.
type geometry interface { area() float64 perim() float64 } I also define 3 other types circle, rectangle and triangle that implement geometry interface. For example, type circle implements all the geometry interface methods as follows.
type circle struct { radius float64 } func (c circle) area() float64 { return math.</description>
    </item>
    
    <item>
      <title>Balanced Binary Search Tree - AVL Tree</title>
      <link>http://www.example.com/docs/balancedbst/</link>
      <pubDate>Sat, 17 Oct 2020 23:10:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/balancedbst/</guid>
      <description>Source code
Introduction AVL tree is a height-balanced binary search tree (BST). In an AVL tree, every node maintains a balance factor, which is defined as follows
balance_factor := height(left_subtree) - height(right_subtree)According to definition of a balanced tree, the balance factor of every node in the AVL tree is either -1, 0, or 1. When an insertion or deletion operation is performed, the tree&amp;rsquo;s height may change, so do the balance factors at nodes.</description>
    </item>
    
    <item>
      <title>Binary Search Tree - Part III</title>
      <link>http://www.example.com/docs/bst-others/</link>
      <pubDate>Sat, 17 Oct 2020 23:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/bst-others/</guid>
      <description>Source code
Fetch maximum value Maximum value of a BST is the value of the most right node
func FetchMax(t *treeNode) int { if t.Right == nil { return t.Value } return FetchMax(t.Right) } Return value: 14
Fetch minimum value Minimum value of a BST is the value of the most left node
func FetchMin(t *treeNode) int { if t.Left == nil { return t.Value } return FetchMin(t.Left) } Return: 1</description>
    </item>
    
    <item>
      <title>Binary Search Tree - Part II</title>
      <link>http://www.example.com/docs/traverse-bst/</link>
      <pubDate>Sat, 17 Oct 2020 22:30:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/traverse-bst/</guid>
      <description>Source code
A traversal is a process of visiting all the nodes in a tree. We can categorise tree&amp;rsquo;s traversal algorithms into 2 groups: depth-first traversal and breadth-first traversal.
 Depth-first traversal: includes PreOrder traversal, InOrder traversal, and PostOrder traversal. Breadth-first traversal: the level order traversal. In this traversal, we visit the node by levels from top to bottom, and from left to right.  Let have a look at implementations of those traversal.</description>
    </item>
    
    <item>
      <title>Binary Search Tree - Part I</title>
      <link>http://www.example.com/docs/bst/</link>
      <pubDate>Sat, 17 Oct 2020 22:00:00 +1100</pubDate>
      
      <guid>http://www.example.com/docs/bst/</guid>
      <description>Source code
Introduction A Binary Tree is a tree data structure, that consists of nodes. The topmost node in the tree is the root. Every node in a Binary Tree has maximum 2 children, which are referred to as left and right child. A leaf is a node that both its left and right subtrees are empty. A node with only one subtree is called half-leaf. A parent of a node is the node immediately above it.</description>
    </item>
    
    <item>
      <title>Mira Jump</title>
      <link>http://www.example.com/project/mirajump/</link>
      <pubDate>Fri, 16 Oct 2020 21:00:00 +1000</pubDate>
      
      <guid>http://www.example.com/project/mirajump/</guid>
      <description>Source code
Description This is a very simple game modified from Flappy Gopher game from Ebiten. It is written in Go using Ebiten library.
Mira is running her scooter. She is going to meet objects on her way, and jumping over them is the only way to go pass. Every time when she successfully avoids an object she will get one point.
How to play Press space key or left-click when you want to jump.</description>
    </item>
    
    <item>
      <title>Simple Slack bot in Go using event API - Stock Bot</title>
      <link>http://www.example.com/project/stockbot/</link>
      <pubDate>Fri, 16 Oct 2020 21:00:00 +1000</pubDate>
      
      <guid>http://www.example.com/project/stockbot/</guid>
      <description>Source code
In this application, we will discuss about stockbot that returns stock prices of a company. The architecture is as follows.
For one who comes to this repository first, I have another repository call weatherbot in which I have described step by step how to build a weatherbot for querying weather conditon of a location. Most of the steps of implementation for two bots are similar, including building a Slack bot user, subscribing to app mentioned event, creating a Go function which is a HTTP handler.</description>
    </item>
    
    <item>
      <title>Simple Slack bot in Go using event API - Weather Bot</title>
      <link>http://www.example.com/project/weatherbot/</link>
      <pubDate>Fri, 16 Oct 2020 20:00:00 +1000</pubDate>
      
      <guid>http://www.example.com/project/weatherbot/</guid>
      <description>Source code
In this repository, I&amp;rsquo;m going to create a weatherbot for querying weather condition of a given location. The idea of writing a Slack bot in Go was inspired by rapidloop&amp;rsquo;s slackbot for RTM API. At the moment, Slack platform provides a range of APIs that Slack apps can access to including events API, web API, Audit Logs APIs beside RTM API which was used in rapidloop&amp;rsquo;s implementation. As RTM API is being phased out in favour of events API, in this application, events API will be used.</description>
    </item>
    
    <item>
      <title>Dining Philosopher problem in Go</title>
      <link>http://www.example.com/docs/dining-philosopher/</link>
      <pubDate>Fri, 16 Oct 2020 14:00:00 +1000</pubDate>
      
      <guid>http://www.example.com/docs/dining-philosopher/</guid>
      <description>Source code
I found that it is an excellent example about Go concurrency and synchronization.
Problem description There are 5 philosophers having their dinner at a round table with one chopstick between each adjacent pair of philosophers. A philosopher can only eat when they have both left and right chopsticks. In other words, while one philosopher is eating, his two adjacent friends have to wait. After eating he puts both chopsticks down to let the others eat.</description>
    </item>
    
  </channel>
</rss>